;;; TODO: Think about the naming convention for "type constructors". Maybe we
;;; could use capitals so the function that produces one can be shorter while
;;; still allowing the lowercase version for variable names.

;;; TODO: Replace with a struct once they exist
(defun make-func (name arity arg-names arg-types return-type impl-type body llvm-func)
  (list name arity arg-names arg-types return-type impl-type body llvm-func))
(defun func-name (func) (first func))
(defun func-arity (func) (second func))
(defun func-arg-names (func) (third func))
(defun func-arg-types (func) (fourth func))
(defun func-return-type (func) (fifth func))
(defun func-impl-type (func) (sixth func))
(defun func-body (func) (seventh func))
(defun func-llvm-func (func) (eighth func))

;;; TODO: Replace with a struct once they exist
(defun make-generic-func (name arity arg-names arg-types return-type body existing-impls)
  (list name arity arg-names arg-types return-type body existing-impls))
(defun generic-func-name (func) (first func))
(defun generic-func-arity (func) (second func))
(defun generic-func-arg-names (func) (third func))
(defun generic-func-arg-types (func) (fourth func))
(defun generic-func-return-type (func) (fifth func))
(defun generic-func-body (func) (sixth func))
(defun generic-func-existing-impls (func) (seventh func))
(defun generic-func-add-impl (func impl-arg-types impl-ret-type impl)
  (set-car (cddr (cddddr func))
           (cons (cons (cons impl-ret-type impl-arg-types) impl)
                 (generic-func-existing-impls func))))

;;; TODO: Replace with a hash table once that exists
;;; TODO: These should go in the context, along with $module and $builder
(defvar $functions nil)
(defvar $generic-functions nil)

;;; TODO: Replace with a struct once they exist
(defun make-context (env file func target-data errors)
  (list env file func target-data errors))
(defun context-env (context) (first context))
(defun context-file (context) (second context))
(defun context-func (context) (third context))
(defun context-target-data (context) (fourth context))
(defun context-errors (context) (fifth context))
(defun context-set-env (context (new-env cons)) (set-car context new-env))
(defun context-set-file (context new-file) (set-car (cdr context) new-file))
(defun context-set-func (context new-func) (set-car (cddr context) new-func))
(defun context-set-target-data (context new-target-data)
  (set-car (cdddr context) new-target-data))
(defun context-set-errors (context new-errors)
  (set-car (cddddr context) new-errors))
(defun push-error (context error)
  (context-set-errors context (cons error (context-errors context))))

(defun make-error (message source-context source-loc)
  (list message source-context source-loc))
(defun error-message (error) (first error))
(defun error-source-context (error) (second error))
(defun error-source-loc (error) (third error))

;;; TODO: Replace with a struct once they exist
;;; TODO: Do we really need this? Couldn't we just have an alist with
;;; car = name and cdr = term?
(defun make-binding (name-token term) (list name-token term))
(defun binding-name-token (binding) (first binding))
(defun binding-term (binding) (second binding))
(defun binding-lvalue? (binding) (tl? (binding-term binding)))
;;; TODO: polymorphic constants?
(defun make-constant (name val typ) (make-binding (dummy-token name)
                                                  (make-term typ val false)))
(defun make-var (name val typ) (make-binding name (make-term typ val true)))

;; The following function is handy for debugging - with 'br nuc(break-on-me)'
;; in .gdbinit, this acts like a breakpoint.
(defun break-on-me () nil)

;;; TODO: When an error occurs in a lambda, we should report the context better
;;; Maybe what we should do is store a chain of context switches terminating at
;;; toplevel form followed by filename, and we push/pop when we enter/leave a
;;; new context?
;;; e.g.: "Error: undefined variable 'foo' in lambda in lambda in function bar in file x.nuc
;;; (could merge adjacent identical contexts, like "lambda (2 levels deep)")
;;; TODO: Rather than panicing, this should return a term containing an LLVM
;;; 'undef' value, and stick the error into a list in the context. That way we
;;; can report multiple errors at once.
(defun fail! (context (message string) source-loc result-type lvalue?)
  (let* ((func (context-func context))
         (typ (cond
                ((eq? (type result-type) foreign-t)
                 result-type)
                ((not (nil? result-type))
                 (llvm-type<-type-spec context result-type))
                (true nil)))
         (final-type (if (and lvalue? (not (nil? result-type)))
                       (LLVMPointerType typ 0)
                       typ))
         (val (if (not (nil? result-type))
                (LLVMGetUndef final-type)
                nil))
         (source-context (if (nil? func)
                           "toplevel form"
                           (format nil "function ~" (func-name func)))))
    ;; When debugging it can be helpful to see errors even if we fail before
    ;; compilation is finished for some reason.
    (when $output-debug-info
      (format true "Got an error: ~" message))
    (break-on-me)
    (push-error context (make-error message source-context source-loc))
    (cond
      ((eq? (type result-type) foreign-t) val)
      ((not (nil? result-type)) (make-term result-type val lvalue?))
      (true nil))))

(defun dummy-token (sexpr)
  (make-token sexpr "<unknown>" 0 0))

(defvar $dummy-source-loc (token-source-loc (dummy-token nil)))

(defun copy-source-loc (token sexpr)
  (make-token sexpr (token-source-name token) (token-line token) (token-col token)))

;; TODO: rename this - tX looks like it is related to terms.
(defun ts (token) (token-sexpr token))

(defun add-func (context name arg-names arg-types return-type impl-type body)
  (when $output-debug-info (format true "Adding func ~" name))
  (if (not (nil? (get-func name)))
    (fail! context
           (format nil "Duplicate definition of function '~'" name)
           ;; TODO: In this case it would be nice to be able to report where
           ;; the other version was. Maybe by issuing a separate (non-error)
           ;; diagnostic with the source-loc of the other function?
           $dummy-source-loc ; TODO: track source loc in 'func's
           nil false)
    (let* ((llvm-return-type (llvm-type<-type-spec context return-type))
           (llvm-arg-types (map (lambda (t) (llvm-type<-type-spec context t))
                                arg-types))
           (arity (length arg-names))
           (llvm-func (declare-function
                        (mangle-name name) llvm-return-type llvm-arg-types))
           (func (make-func name arity arg-names arg-types return-type impl-type body llvm-func)))
      (set $functions (cons (cons name func) $functions)))))

(defun add-generic-func (context name arg-names arg-types return-type
                                 return-type-source-loc body)
  (when $output-debug-info (format true "Adding generic func ~" name))
  (let* ((arity (length arg-names))
         (generic-func (make-generic-func name arity arg-names
                                          arg-types return-type body nil))
         (dynamic-arg-types (map (lambda (arg-type)
                                   (if (generic-type? arg-type) '? arg-type))
                                 arg-types)))
    (if (and (generic-type? return-type)
             (not (member? return-type arg-types)))
      (fail! context
             (format nil "Generic return type ~ must be constrained by generic argument types" return-type)
             return-type-source-loc
             nil false)
      ;; By the gradual guarantee, if the function fails to compile when all of
      ;; the type variables are replaced with '?', it will fail with *any*
      ;; concrete type. If that is the case, we know not to bother creating any
      ;; other versions, and we can just issue one error message. To do this,
      ;; we create a dummy non-generic version with a signature with all
      ;; variables replaced with '?'.
      ;;
      ;; This is nice because we can still get type errors for any non-dynamic
      ;; concrete types in the signature even if the function itself failed to
      ;; compile. We also set its impl-type to 'extern', so that we don't
      ;; bother to compile this non-generic version. It doesn't matter that it
      ;; doesn't exist, as we'll fail before link time.
      ;;
      ;; TODO: We can't do the above yet, as we can't compile functions until
      ;; we have processed the entire compilation unit. We need to delay it
      ;; somehow, while still making sure it happens before any other functions
      ;; are compiled, so that they refer to the non-generic version if it
      ;; fails.
      (set $generic-functions (cons (cons name generic-func) $generic-functions)))))

(defun generic-type? (type-spec)
  ;; TODO: Support compound types containing type variables
  (and (not (cons? type-spec))
       (eq? (char-at (string<-symbol type-spec) 0) 36))) ; 36 = '$'

(defun get-generic-func-specialization (context generic-func concrete-arg-types
                                                concrete-ret-type blame-source-loc)
  (let ((existing (find (lambda (pair)
                          (let ((arg-types (car pair))
                                (impl (cdr pair)))
                            (all? (lambda (c)
                                    (type-eq? (car c) (cdr c)))
                                  (zip arg-types concrete-arg-types))))
                        (generic-func-existing-impls generic-func))))
    (cond
      ((not (nil? existing))
       (cdr existing))
      ((not (generic-func-compatible? generic-func concrete-arg-types))
       (fail! context
              (format nil "Incompatible types to generic function ~"
                      (generic-func-name generic-func))
              blame-source-loc
              nil false)
       (declare-function "(dummy)" (concrete-ret-type generic-func)
                         concrete-arg-types))
      (true
        (let ((new-impl (compile-generic-function-impl
                          context generic-func concrete-arg-types
                          concrete-ret-type)))
          (generic-func-add-impl generic-func concrete-arg-types
                                 concrete-ret-type new-impl)
          new-impl)))))

(defun generic-func-compatible? (generic-func concrete-arg-types)
  (all? (lambda (c)
          (let ((desired-type (car c))
                (actual-type (cdr c)))
            (or (generic-type? desired-type)
                (type-eq? desired-type actual-type))))
        (zip (generic-func-arg-types generic-func) concrete-arg-types)))

(defun get-concrete-types (context generic-func arg-terms)
  (let* ((type-var-map nil)
         (concrete-arg-types
           (map2 (lambda (func-arg-type arg-term)
                   (if (generic-type? func-arg-type)
                     (let ((already-found (assoc-cdr func-arg-type type-var-map)))
                       (if (not (nil? already-found))
                         already-found
                         (let ((t (tt arg-term)))
                           (set type-var-map (cons (cons func-arg-type t) type-var-map))
                           t)))
                     ;; Don't bother checking if they match, as the coercion will get
                     ;; that later anyway.
                     func-arg-type))
                 (generic-func-arg-types generic-func)
                 arg-terms))
         (ret-type (generic-func-return-type generic-func))
         (concrete-ret-type
           (if (generic-type? ret-type)
             (let ((already-found (assoc-cdr ret-type type-var-map)))
               (assert! (not (nil? already-found))
                        "The return type is a type variable and is not constrained by argument type variables. Should have detected this when processing the function declaration")
               already-found)
             ret-type)))
    (cons concrete-ret-type concrete-arg-types)))

(defun add-global (context name type-spec)
  (let* ((global (LLVMAddGlobal $module NUC-VAL (mangle-name (ts name)))))
    (context-set-env context (cons (make-var name global type-spec)
                                   (context-env context)))
    global))

(defun get-func (name) (assoc-cdr name $functions))
(defun get-generic-func (name) (assoc-cdr name $generic-functions))

(defvar $initialisers nil)

(defun add-initialiser (var init)
  (set $initialisers (cons (cons var init) $initialisers)))

(defun mangle-name (name) (format nil "nuc(~)" name))
(defun mangle-generic-func-name (name concrete-arg-types concrete-ret-type)
  (format nil "nuc-generic(~$~->~)" name concrete-arg-types concrete-ret-type))
(defvar $proxy-count 0)
(defun mangle-proxy-func-name (original-arg-types proxy-arg-types)
  (format nil "nuc-proxy(~_~->~)"
          (set $proxy-count (+ $proxy-count 1))
          original-arg-types
          proxy-arg-types))

;; TODO: write this properly
(defun << (x y) (* x (expt 2 y)))

(defun extend-env-with-terms (context name-tokens terms)
  (let ((env (context-env context)))
    (each (lambda (name-and-term)
            (let* ((name (car name-and-term))
                   (term (cdr name-and-term))
                   (var-on-stack (LLVMBuildAlloca $builder
                                                  (llvm-type<-type-spec context (tt term))
                                                  (string<-symbol (ts name)))))
              (LLVMBuildStore $builder (tv term) var-on-stack)
              (set env (cons (make-var name var-on-stack (tt term)) env))))
          (zip name-tokens terms))
    (context-set-env context env)))

(defun extend-env-with-bindings (context bindings)
  (context-set-env context (append bindings (context-env context))))

(defun declare-function (name ret-type arg-types)
  (LLVMAddFunction
    $module
    name
    (LLVMFunctionType ret-type arg-types (length arg-types) false)))

;; TODO: functions as values are still kinda separate, maybe they should also
;; be integrated into the environment somehow?

(defun get-binding (context name)
  (find (lambda (binding) (eq? (ts (binding-name-token binding)) name))
        (context-env context)))

(defun gc-alloc (size)
  (llvm-build-call
    $builder (runtime-func "gc_alloc" (LLVMPointerType NUC-VAL 0) (list SIZE-T))
    (list (llvm-i64<-int size)) "gc_alloc"))

(defun get-car-ptr (cons-ptr) (LLVMBuildStructGEP $builder cons-ptr 0 "car"))
(defun get-cdr-ptr (cons-ptr) (LLVMBuildStructGEP $builder cons-ptr 1 "cdr"))
(defun get-gr-ptr (cons-ptr) (LLVMBuildStructGEP $builder cons-ptr 2 "gr"))

(defun get-car-value (cons-ptr) (LLVMBuildLoad $builder (get-car-ptr cons-ptr) ""))
(defun get-cdr-value (cons-ptr) (LLVMBuildLoad $builder (get-cdr-ptr cons-ptr) ""))
(defun get-gr-value (cons-ptr) (LLVMBuildLoad $builder (get-gr-ptr cons-ptr) ""))
(defun get-car-gr-value (cons-ptr)
  (LLVMBuildICmp $builder LLVMIntNE
                 (LLVMBuildAnd $builder (get-gr-value cons-ptr) (llvm-i8<-int 2) "")
                 (llvm-i8<-int 0)
                 ""))
(defun get-cdr-gr-value (cons-ptr)
  (LLVMBuildICmp $builder LLVMIntNE
                 (LLVMBuildAnd $builder (get-gr-value cons-ptr) (llvm-i8<-int 1) "")
                 (llvm-i32<-int 0)
                 ""))

(defun set-car-value (cons-ptr val) (LLVMBuildStore $builder val (get-car-ptr cons-ptr)))
(defun set-cdr-value (cons-ptr val) (LLVMBuildStore $builder val (get-cdr-ptr cons-ptr)))
(defun set-gr-value (cons-ptr val) (LLVMBuildStore $builder val (get-gr-ptr cons-ptr)))

(defun cons-size (context)
  (LLVMABISizeOfType (context-target-data context) CONS-CELL))

(defun compile-progn (context forms)
  (%compile-progn context (if (nil? forms) (list (dummy-token 'nil)) forms)))

(defun %compile-progn (context forms)
  (let ((e (compile-expr context (car forms))))
    (if (nil? (cdr forms))
      e
      (%compile-progn context (cdr forms)))))

(defun remove-tokens-from-type (typ)
  (if (cons? (ts typ))
     (map remove-tokens-from-type (ts typ))
     (ts typ)))

;;; TODO: this feels kinda janky
(defun parse-arg-list (context arg-list-token)
  (let* ((arg-list (ts arg-list-token))
         (arg-names
           (map
             (lambda (arg)
               (case (type (ts arg))
                 (cons-t (first (ts arg)))
                 (symbol-t arg)
                 (default
                   (fail! context (format nil "Invalid argument expression: ~" (ts arg))
                          (token-source-loc arg)
                          nil false)
                   (dummy-token (gensym)))))
             arg-list))
         (arg-types
           (map
             (lambda (arg)
               (case (type (ts arg))
                 (cons-t (remove-tokens-from-type (second (ts arg))))
                 (symbol-t '?)
                 (default
                   (fail! context (format nil "Invalid argument expression: ~" arg)
                          (token-source-loc arg)
                          nil false)
                   '?)))
             arg-list)))
    (cons arg-names arg-types)))

;; TODO: allow type annotations for lambdas
(defun compile-lambda (context source-loc name arg-list body captured-bindings)
  (let* ((old-func (context-func context))
         (params (repeat (length arg-list) NUC-VAL))
         (names-and-types (parse-arg-list context arg-list))
         (arg-names (car names-and-types))
         (arg-types (cdr names-and-types))
         ;; We only take the lambda struct as our first argument if we have
         ;; any captured bindings. This allows us to easily deal with passing
         ;; around static functions in lambdas.
         ;; TODO: We could optimize further by not allocating a new closure if
         ;; we don't capture any bindings, and instead just creating a static
         ;; closure once at compile-time and returning it every time.
         (func (declare-function (mangle-name name) NUC-VAL
                                 (if (nil? captured-bindings)
                                   params
                                   (cons (LLVMPointerType CLOSURE 0) params)))))
    ;; TODO: parse return type declarations
    (context-set-func
      context
      (make-func name (length arg-names) arg-names arg-types '? body 'nucleus func))
    ;; TODO: set LLVM param names
    (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock func "entry"))
    (let* ((params (llvm-params func))
           (original-env (context-env context)))
      (extend-env-with-bindings
        context
        (map2 (lambda (i binding)
                (make-var
                  (binding-name-token binding)
                  (LLVMBuildBitCast
                    $builder
                    (LLVMBuildLoad
                      $builder
                      (LLVMBuildGEP
                        $builder
                        (LLVMBuildGEP $builder (first params)
                                      (map llvm-i32<-int (list 0 3))
                                      2
                                      "")
                        (map llvm-i64<-int (list 0 i))
                        2
                        "get-var-from-closure")
                      "")
                    (LLVMPointerType
                      (llvm-type<-type-spec
                        context (tt (binding-term binding)))
                      0)
                    "")
                  (tt (binding-term binding))))
              (range (length captured-bindings))
              captured-bindings))
      (extend-env-with-terms
        context
        arg-names
        (map2 (lambda (typ val) (make-term typ val true))
              (repeat (length arg-list) '?)
              (if (nil? captured-bindings)
                (llvm-params func)
                (cdr (llvm-params func)))))
      ;; TODO: once we're parsing lambda return type declarations this should
      ;; use them rather than always using ?
      (LLVMBuildRet $builder (tv (coerce context (compile-progn context body) '?
                                         (token-source-loc
                                           (if (nil? body) source-loc (car (last body)))))))
      (when (LLVMVerifyFunction func LLVMPrintMessageAction)
        (LLVMDumpValue func)
        (fail! context
               (format nil "ICE compiling lambda ~ (failed LLVMVerifyFunction). Function has been dumped" name)
               source-loc
               nil false))
      (context-set-func context old-func)
      (context-set-env context original-env))
    func))

(defun call-closure (context closure-term arg-terms proxy?)
  (let* ((num-args (length arg-terms))
         (arity (func-type-arity (tt closure-term))))
    (when $output-debug-info
      (format true "(call-closure ... ~ ~)" closure-term arg-terms))
    (if (not (eq? num-args arity))
      (fail! context
             (format nil "Invalid number of args to closure (got ~, expected ~)"
                     num-args arity)
             ;; TODO: source loc
             $dummy-source-loc
             (fourth (tt closure-term)) true)
      (let* ((current-func (get-current-func $builder))
             (num-captures
               (LLVMBuildLoad $builder
                              (LLVMBuildStructGEP $builder (tv closure-term) 2 "")
                              "num-captures"))
             (func-pointer
               (if proxy?
                 (LLVMBuildPtrToInt
                   $builder
                   (LLVMBuildLoad
                     $builder
                     (LLVMBuildGEP
                       $builder
                       (LLVMBuildGEP $builder (tv closure-term)
                                     (map llvm-i32<-int (list 0 3)) 2 "")
                       (list (llvm-i64<-int 0)
                             (LLVMBuildSub $builder num-captures (llvm-i32<-int 1) ""))
                       2
                       "get-wrapped-func-pointer-from-closure")
                     "")
                   UINTPTR
                   "")
                 (LLVMBuildLoad
                   $builder
                   (LLVMBuildStructGEP $builder (tv closure-term) 0 "")
                   "load-func-pointer-from-struct")))
             (arg-types (func-type-arg-types (tt closure-term)))
             (llvm-arg-types
               (map (lambda (type-spec)
                      (llvm-type<-type-spec context type-spec))
                    arg-types))
             (llvm-return-type
               (llvm-type<-type-spec
                 context
                 (func-type-return-type (tt closure-term)))))
        ;; TODO: This is a case where a "declare in current scope" special form
        ;; could be really useful - a bunch of assignments interspersed with
        ;; side-effecting calls
        (let ((then-block (LLVMAppendBasicBlock current-func "doesn't-take-closure"))
              (else-block (LLVMAppendBasicBlock current-func "takes-closure"))
              (after-block (LLVMAppendBasicBlock current-func "after-call"))
              (coerced-args
                (map2 (lambda (arg-term typ)
                        ;; TODO: source loc
                        (tv (coerce context arg-term typ $dummy-source-loc)))
                      arg-terms
                      arg-types)))
          (LLVMBuildCondBr
            $builder
            (LLVMBuildICmp $builder LLVMIntEQ num-captures
                           (llvm-i32<-int (if proxy? 1 0)) "")
            then-block
            else-block)
          (LLVMPositionBuilderAtEnd $builder then-block)
          (let ((then-result
                  (llvm-build-call
                    $builder
                    (LLVMBuildIntToPtr
                      $builder
                      func-pointer
                      (LLVMPointerType
                        (LLVMFunctionType llvm-return-type
                                          llvm-arg-types arity false)
                        0)
                      "cast-to-correct-function-type")
                    coerced-args
                    "call-closure")))
            (LLVMBuildBr $builder after-block)
            (LLVMPositionBuilderAtEnd $builder else-block)
            (let ((else-result
                    (llvm-build-call
                      $builder
                      (LLVMBuildIntToPtr
                        $builder
                        func-pointer
                        (LLVMPointerType
                          (LLVMFunctionType
                            llvm-return-type
                            (cons CLOSURE-PTR llvm-arg-types)
                            (+ 1 arity)
                            false)
                          0)
                        "cast-to-correct-function-type")
                      (cons (tv closure-term) coerced-args)
                      "call-closure")))
              (LLVMBuildBr $builder after-block)
              (LLVMPositionBuilderAtEnd $builder after-block)
              (llvm-phi $builder llvm-return-type
                        (list (cons then-result then-block)
                              (cons else-result else-block))
                        "closure-call"))))))))

(defun make-lambda (context llvm-func arg-types return-type captures)
  (let* ((arity (length arg-types))
         (ary-type (LLVMArrayType (LLVMPointerType NUC-VAL 0) (length captures)))
         (captures-array
           (if (nil? captures)
             (LLVMConstNull ary-type)
             (LLVMBuildAlloca $builder ary-type "make-captures-array"))))
    (enumerate (lambda (i capture)
                 (assert! (binding-lvalue? capture) "Captures should be lvalues")
                 ;; TODO: insert-value?
                 (LLVMBuildStore
                   $builder
                   (tv (binding-term capture))
                   (LLVMBuildBitCast
                     $builder
                     (LLVMBuildGEP $builder captures-array
                                   (map llvm-i64<-int (list 0 i))
                                   2 "array-elt")
                     (LLVMPointerType
                       (LLVMPointerType
                         (llvm-type<-type-spec context (tt (binding-term capture)))
                         0)
                       0)
                     "")))
               captures)
    (make-term
      (list 'func arg-types '-> return-type)
      (llvm-build-call
        $builder
        (runtime-func "rt_make_lambda" CLOSURE-PTR
                      (list UINTPTR (LLVMIntType 8) (LLVMIntType 32) UINTPTR))
        (list (LLVMBuildPtrToInt $builder llvm-func UINTPTR "func-pointer-to-int")
              (llvm-i8<-int arity)
              (llvm-i32<-int (length captures))
              (if (nil? captures)
                (llvm-i64<-int 0)
                (LLVMBuildPtrToInt $builder captures-array UINTPTR "array-to-int")))
        "make-lambda")
      false)))

(defun compile-proxy-function (context closure-term proxy-func-type)
  (when $output-debug-info
    (format true "(c-p-f ... ~ ~)" closure-term proxy-func-type))
  (let* ((original-arg-types (func-type-arg-types (tt closure-term)))
         (original-return-type (func-type-return-type (tt closure-term)))
         (original-block (LLVMGetInsertBlock $builder))
         (proxy-arg-types (func-type-arg-types proxy-func-type))
         (proxy-return-type (func-type-return-type proxy-func-type))
         (proxy-func (declare-function
                       (mangle-proxy-func-name original-arg-types proxy-arg-types)
                       (llvm-type<-type-spec context proxy-return-type)
                       (cons CLOSURE-PTR
                             (map (lambda (t) (llvm-type<-type-spec context t))
                                  proxy-arg-types)))))
    (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock proxy-func "entry"))
    (let* ((params (llvm-params proxy-func))
           (closure-ptr (first params)))
      (LLVMBuildRet
        $builder
        (tv (coerce
              context
              (make-term
                original-return-type
                (call-closure
                  context
                  (make-term (tt closure-term) (first params) false)
                  (map2 (lambda (param typ) (make-term typ param false))
                        (rest params)
                        proxy-arg-types)
                  true)
                false)
              proxy-return-type
              $dummy-source-loc))))
    (LLVMPositionBuilderAtEnd $builder original-block)
    (llvm-build-call
      $builder
      (runtime-func "rt_proxy_for_lambda" CLOSURE-PTR (list CLOSURE-PTR UINTPTR))
      (list (tv closure-term)
            (LLVMBuildPtrToInt $builder proxy-func UINTPTR "func-pointer-to-int"))
      "make-proxy-lambda")))

(defun runtime-func (name return-type arg-types)
  (let ((func (LLVMGetNamedFunction $module name)))
    (if (null? func)
      (declare-function name return-type arg-types)
      func)))

(defun global-string (str)
  (LLVMBuildGEP
    $builder
    (LLVMBuildGlobalString $builder str "")
    (list (llvm-i64<-int 0) (llvm-i64<-int 0))
    2
    "str-to-ptr"))

(defun find-captured-vars (context body args)
  (unique (%find-captured-vars context body args)))

(defun %find-captured-vars (context sexpr to-ignore)
  (cond
    ((atom? sexpr)
     (if (member? sexpr to-ignore)
       nil
       (let ((binding (get-binding context sexpr)))
         (if (and (not (nil? binding))
                  (binding-lvalue? binding))
           (list binding)
           nil))))
    ((eq? (ts (car sexpr)) 'let)
     ;; Any variables introduced by let obviously aren't captures for the
     ;; duration of the let body, so we ignore them. This includes both new
     ;; variables and shadowing of old ones.
     (let ((to-ignore (append! (map (lambda (x) (ts (car (ts x))))
                                    (ts (second sexpr)))
                               to-ignore)))
       (append!
         (mappend (lambda (clause)
                    (%find-captured-vars context (ts (second (ts clause))) to-ignore))
                  (ts (second sexpr)))
         (%find-captured-vars context (cddr sexpr) to-ignore))))
    (true (mappend (lambda (e) (%find-captured-vars context (ts e) to-ignore)) sexpr))))

(defun simple-int-cmp (val1 val2)
  (make-term
    'bool
    (LLVMBuildZExt
      $builder
      (LLVMBuildICmp $builder LLVMIntEQ val1 val2 "")
      (LLVMIntType 32)
      "")
    false))
