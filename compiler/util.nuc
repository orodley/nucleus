;;; TODO: Think about the naming convention for "type constructors". Maybe we
;;; could use capitals so the function that produces one can be shorter while
;;; still allowing the lowercase version for variable names.

;;; TODO: Replace with a struct once they exist
(defun make-func (name arity arg-names arg-types return-type impl-type body llvm-func)
  (list name arity arg-names arg-types return-type impl-type body llvm-func))
(defun func-name (func) (first func))
(defun func-arity (func) (second func))
(defun func-arg-names (func) (third func))
(defun func-arg-types (func) (fourth func))
(defun func-return-type (func) (fifth func))
(defun func-impl-type (func) (sixth func))
(defun func-body (func) (seventh func))
(defun func-llvm-func (func) (eighth func))

;;; TODO: Replace with a hash table once that exists
;;; TODO: These should go in the context, along with $module and $builder
(defvar $functions nil)

;;; TODO: Replace with a struct once they exist
(defun make-context (env file func target-data errors)
  (list env file func target-data errors))
(defun context-env (context) (first context))
(defun context-file (context) (second context))
(defun context-func (context) (third context))
(defun context-target-data (context) (fourth context))
(defun context-errors (context) (fifth context))
(defun context-set-env (context (new-env cons)) (set-car context new-env))
(defun context-set-file (context new-file) (set-car (cdr context) new-file))
(defun context-set-func (context new-func) (set-car (cddr context) new-func))
(defun context-set-target-data (context new-target-data)
  (set-car (cdddr context) new-target-data))
(defun context-set-errors (context new-errors)
  (set-car (cddddr context) new-errors))
(defun push-error (context error)
  (context-set-errors context (cons error (context-errors context))))

(defun make-error (message source-context source-loc)
  (list message source-context source-loc))
(defun error-message (error) (first error))
(defun error-source-context (error) (second error))
(defun error-source-loc (error) (third error))

;;; TODO: Replace with a struct once they exist
;;; TODO: Do we really need this? Couldn't we just have an alist with
;;; car = name and cdr = term?
(defun make-binding (name-token term) (list name-token term))
(defun binding-name-token (binding) (first binding))
(defun binding-term (binding) (second binding))
(defun binding-lvalue? (binding) (tl? (binding-term binding)))
;;; TODO: polymorphic constants?
(defun make-constant (name val typ) (make-binding (dummy-token name)
                                                  (make-term typ val false)))
(defun make-var (name val typ) (make-binding name (make-term typ val true)))

;; The following function is handy for debugging - with 'br nuc(break-on-me)'
;; in .gdbinit, this acts like a breakpoint.
(defun break-on-me () nil)

;;; TODO: When an error occurs in a lambda, we should report the context better
;;; Maybe what we should do is store a chain of context switches terminating at
;;; toplevel form followed by filename, and we push/pop when we enter/leave a
;;; new context?
;;; e.g.: "Error: undefined variable 'foo' in lambda in lambda in function bar in file x.nuc
;;; (could merge adjacent identical contexts, like "lambda (2 levels deep)")
;;; TODO: Rather than panicing, this should return a term containing an LLVM
;;; 'undef' value, and stick the error into a list in the context. That way we
;;; can report multiple errors at once.
(defun fail! (context (message string) source-loc result-type lvalue?)
  (let* ((func (context-func context))
         (typ (cond
                ((eq? (type result-type) foreign-t)
                 result-type)
                ((not (nil? result-type))
                 (llvm-type<-type-spec context result-type))
                (true nil)))
         (final-type (if (and lvalue? (not (nil? result-type)))
                       (LLVMPointerType typ 0)
                       typ))
         (val (if (not (nil? result-type))
                (LLVMGetUndef final-type)
                nil))
         (source-context (if (nil? func)
                           "toplevel form"
                           (format nil "function ~" (func-name func)))))
    ;; When debugging it can be helpful to see errors even if we fail before
    ;; compilation is finished for some reason.
    (when $output-debug-info
      (format true "Got an error: ~" message))
    (push-error context (make-error message source-context source-loc))
    (cond
      ((eq? (type result-type) foreign-t) val)
      ((not (nil? result-type)) (make-term result-type val lvalue?))
      (true nil))))

(defun dummy-token (sexpr)
  (make-token sexpr "<unknown>" 0 0))

(defvar $dummy-source-loc (token-source-loc (dummy-token nil)))

(defun copy-source-loc (token sexpr)
  (make-token sexpr (token-source-name token) (token-line token) (token-col token)))

;; TODO: rename this - tX looks like it is related to terms.
(defun ts (token) (token-sexpr token))

(defun add-func (context name arg-names arg-types return-type impl-type body)
  (let* ((llvm-return-type (llvm-type<-type-spec context return-type))
         (llvm-arg-types (map (lambda (t) (llvm-type<-type-spec context t))
                              arg-types))
         (arity (length arg-names))
         (llvm-func (declare-function
                      (mangle-name name) llvm-return-type llvm-arg-types))
         (func (make-func name arity arg-names arg-types return-type impl-type body llvm-func)))
    (cond
      ((not (nil? (get-func name)))
       (fail! context
              (format nil "Duplicate definition of function '~'" name)
              $dummy-source-loc ; TODO: track source loc in 'func's
              nil false))
      (true
        (set $functions (cons (cons name func) $functions))))))

(defun add-global (context name type-spec)
  (let* ((global (LLVMAddGlobal $module NUC-VAL (mangle-name name))))
    (context-set-env context (cons (make-var name global type-spec)
                                   (context-env context)))
    global))

(defun get-func (name) (assoc-cdr name $functions))

(defvar $initialisers nil)

(defun add-initialiser (var init)
  (set $initialisers (cons (cons var init) $initialisers)))

(defun mangle-name (name) (format nil "nuc(~)" name))

;; TODO: write this properly
(defun << (x y) (* x (expt 2 y)))

(defun extend-env-with-terms (context name-tokens terms)
  (let ((env (context-env context)))
    (each (lambda (name-and-term)
            (let* ((name (car name-and-term))
                   (term (cdr name-and-term))
                   (var-on-stack (LLVMBuildAlloca $builder
                                                  (llvm-type<-type-spec context (tt term))
                                                  (string<-symbol (ts name)))))
              (LLVMBuildStore $builder (tv term) var-on-stack)
              (set env (cons (make-var name var-on-stack (tt term)) env))))
          (zip name-tokens terms))
    (context-set-env context env)))

(defun extend-env-with-bindings (context bindings)
  (context-set-env context (append bindings (context-env context))))

(defun declare-function (name ret-type arg-types)
  (LLVMAddFunction
    $module
    name
    (LLVMFunctionType ret-type arg-types (length arg-types) false)))

;; TODO: functions as values are still kinda separate, maybe they should also
;; be integrated into the environment somehow?

(defun get-binding (context name)
  (find (lambda (binding) (eq? (ts (binding-name-token binding)) name))
        (context-env context)))

(defun gc-alloc (size)
  (llvm-build-call
    $builder (runtime-func "gc_alloc" (LLVMPointerType NUC-VAL 0) (list SIZE-T))
    (list (llvm-i64<-int size)) "gc_alloc"))

(defun get-car-ptr (cons-ptr) (LLVMBuildStructGEP $builder cons-ptr 0 "car"))
(defun get-cdr-ptr (cons-ptr) (LLVMBuildStructGEP $builder cons-ptr 1 "cdr"))
(defun get-gr-ptr (cons-ptr) (LLVMBuildStructGEP $builder cons-ptr 2 "gr"))

(defun get-car-value (cons-ptr) (LLVMBuildLoad $builder (get-car-ptr cons-ptr) ""))
(defun get-cdr-value (cons-ptr) (LLVMBuildLoad $builder (get-cdr-ptr cons-ptr) ""))
(defun get-gr-value (cons-ptr) (LLVMBuildLoad $builder (get-gr-ptr cons-ptr) ""))
(defun get-car-gr-value (cons-ptr)
  (LLVMBuildICmp $builder LLVMIntNE
                 (LLVMBuildAnd $builder (get-gr-value cons-ptr) (llvm-i8<-int 2) "")
                 (llvm-i8<-int 0)
                 ""))
(defun get-cdr-gr-value (cons-ptr)
  (LLVMBuildICmp $builder LLVMIntNE
                 (LLVMBuildAnd $builder (get-gr-value cons-ptr) (llvm-i8<-int 1) "")
                 (llvm-i32<-int 0)
                 ""))

(defun set-car-value (cons-ptr val) (LLVMBuildStore $builder val (get-car-ptr cons-ptr)))
(defun set-cdr-value (cons-ptr val) (LLVMBuildStore $builder val (get-cdr-ptr cons-ptr)))
(defun set-gr-value (cons-ptr val) (LLVMBuildStore $builder val (get-gr-ptr cons-ptr)))

(defun cons-size (context)
  (LLVMABISizeOfType (context-target-data context) CONS-CELL))

(defun compile-progn (context forms)
  (%compile-progn context (if (nil? forms) (list (dummy-token 'nil)) forms)))

(defun %compile-progn (context forms)
  (let ((e (compile-expr context (car forms))))
    (if (nil? (cdr forms))
      e
      (%compile-progn context (cdr forms)))))

(defun remove-tokens-from-type (typ)
  (if (cons? (ts typ))
     (map remove-tokens-from-type (ts typ))
     (ts typ)))

;;; TODO: this feels kinda janky
(defun parse-arg-list (context arg-list-token)
  (let* ((arg-list (ts arg-list-token))
         (arg-names
           (map
             (lambda (arg)
               (case (type (ts arg))
                 (cons-t (first (ts arg)))
                 (symbol-t arg)
                 (default
                   (fail! context (format nil "Invalid argument expression: ~" (ts arg))
                          (token-source-loc arg)
                          nil false)
                   (dummy-token (gensym)))))
             arg-list))
         (arg-types
           (map
             (lambda (arg)
               (case (type (ts arg))
                 (cons-t (remove-tokens-from-type (second (ts arg))))
                 (symbol-t '?)
                 (default
                   (fail! context (format nil "Invalid argument expression: ~" arg)
                          (token-source-loc arg)
                          nil false)
                   '?)))
             arg-list)))
    (cons arg-names arg-types)))

;; TODO: allow type annotations for lambdas
(defun compile-lambda (context source-loc name arg-list body captured-bindings)
  (let* ((old-func (context-func context))
         (params (repeat (length arg-list) NUC-VAL))
         (names-and-types (parse-arg-list context arg-list))
         (arg-names (car names-and-types))
         (arg-types (cdr names-and-types))
         ;; We only take the lambda struct as our first argument if we have
         ;; any captured bindings. This allows us to easily deal with passing
         ;; around static functions in lambdas.
         ;; TODO: We could optimize further by not allocating a new closure if
         ;; we don't capture any bindings, and instead just creating a static
         ;; closure once at compile-time and returning it every time.
         (func (declare-function (mangle-name name) NUC-VAL
                                 (if (nil? captured-bindings)
                                   params
                                   (cons (LLVMPointerType CLOSURE 0) params)))))
    ;; TODO: parse return type declarations
    (context-set-func
      context
      (make-func name (length arg-names) arg-names arg-types '? body 'nucleus func))
    ;; TODO: set LLVM param names
    (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock func "entry"))
    (let* ((params (llvm-params func))
           (original-env (context-env context)))
      (extend-env-with-bindings
        context
        (map2 (lambda (i binding)
                (make-var
                  (binding-name-token binding)
                  (LLVMBuildBitCast
                    $builder
                    (LLVMBuildLoad
                      $builder
                      (LLVMBuildGEP
                        $builder
                        (LLVMBuildGEP $builder (first params)
                                      (map llvm-i32<-int (list 0 2))
                                      2
                                      "")
                        (map llvm-i64<-int (list 0 i))
                        2
                        "get-var-from-closure")
                      "")
                    (LLVMPointerType
                      (llvm-type<-type-spec
                        context (tt (binding-term binding)))
                      0)
                    "")
                  (tt (binding-term binding))))
              (range (length captured-bindings))
              captured-bindings))
      (extend-env-with-terms
        context
        arg-names
        (map2 (lambda (typ val) (make-term typ val true))
              (repeat (length arg-list) '?)
              (if (nil? captured-bindings)
                (llvm-params func)
                (cdr (llvm-params func)))))
      ;; TODO: once we're parsing lambda return type declarations this should
      ;; use them rather than always using ?
      (LLVMBuildRet $builder (tv (coerce context (compile-progn context body) '?
                                         (token-source-loc
                                           (if (nil? body) source-loc (car (last body)))))))
      (when (LLVMVerifyFunction func LLVMPrintMessageAction)
        (LLVMDumpValue func)
        (fail! context
               (format nil "ICE compiling lambda ~ (failed LLVMVerifyFunction). Function has been dumped" name)
               source-loc
               nil false))
      (context-set-func context old-func)
      (context-set-env context original-env))
    func))

;;; TODO: We need RTTI for closures and proper static function types so we can
;;; do more complete type checking, at compile-time or runtime depending on
;;; whether the type can be deduced.
;;; TODO: We should at least check it has the 'lambda' lowtag even if we can't
;;; do the full check.
(defun call-closure (context val args)
  (let* ((closure (LLVMBuildIntToPtr
                    $builder (remove-lowtag val) (LLVMPointerType CLOSURE 0) ""))
         (func-pointer
           (LLVMBuildLoad
             $builder
             ;; TODO: BuildStructGEP?
             (LLVMBuildGEP
               $builder
               closure
               (map llvm-i32<-int (list 0 0))
               2
               "")
             "load-func-pointer-from-struct"))
         (current-func (get-current-func $builder))
         (args-len (length args))
         (captures
           (LLVMBuildGEP
             $builder
             (LLVMBuildGEP $builder closure (map llvm-i32<-int (list 0 2)) 2 "")
             (map llvm-i32<-int (list 0 0))
             2
             ""))
         (first-capture (LLVMBuildLoad $builder captures "")))
    ;; TODO: This is a case where a "declare in current scope" special form
    ;; could be really useful - a bunch of assignments interspersed with
    ;; side-effecting calls
    (let ((then-block (LLVMAppendBasicBlock current-func "doesn't-take-closure"))
          (else-block (LLVMAppendBasicBlock current-func "takes-closure"))
          (after-block (LLVMAppendBasicBlock current-func "after-call"))
          ;; TODO: Coerce based on RTTI
          (coerced-args
            (map (lambda (arg-token)
                   (tv (coerce context (compile-expr context arg-token) '?
                               (token-source-loc arg-token))))
                 args)))
      (LLVMBuildCondBr
        $builder
        (LLVMBuildICmp $builder LLVMIntEQ
                       (LLVMBuildPtrToInt $builder first-capture UINTPTR "")
                       (llvm-i64<-int 0) "")
        then-block
        else-block)
      (LLVMPositionBuilderAtEnd $builder then-block)
      (let ((then-result (llvm-build-call
                           $builder
                           (LLVMBuildIntToPtr
                             $builder
                             func-pointer
                             (LLVMPointerType
                               (LLVMFunctionType
                                 NUC-VAL
                                 (repeat args-len NUC-VAL)
                                 args-len
                                 false)
                               0)
                             "cast-to-correct-function-type")
                           coerced-args
                           "call-closure")))
        (LLVMBuildBr $builder after-block)
        (LLVMPositionBuilderAtEnd $builder else-block)
        (let ((else-result
                (llvm-build-call
                  $builder
                  (LLVMBuildIntToPtr
                    $builder
                    func-pointer
                    (LLVMPointerType
                      (LLVMFunctionType
                        NUC-VAL
                        (cons (LLVMPointerType CLOSURE 0)
                              (repeat args-len NUC-VAL))
                        (+ 1 args-len)
                        false)
                      0)
                    "cast-to-correct-function-type")
                  (cons closure coerced-args)
                  "call-closure")))
          (LLVMBuildBr $builder after-block)
          (LLVMPositionBuilderAtEnd $builder after-block)
          (llvm-phi $builder NUC-VAL (list (cons then-result then-block)
                                           (cons else-result else-block))
                    "closure-call"))))))

(defun make-lambda (context func arity captures)
  (let* ((ary-type (LLVMArrayType (LLVMPointerType NUC-VAL 0) (length captures)))
         (captures-array
           (if (nil? captures)
             (LLVMConstNull ary-type)
             (LLVMBuildAlloca $builder ary-type "make-captures-array"))))
    (enumerate (lambda (i capture)
                 (assert! (binding-lvalue? capture) "Captures should be lvalues")
                 ;; TODO: insert-value?
                 (LLVMBuildStore
                   $builder
                   (tv (binding-term capture))
                   (LLVMBuildBitCast
                     $builder
                     (LLVMBuildGEP $builder captures-array
                                   (map llvm-i64<-int (list 0 i))
                                   2 "array-elt")
                     (LLVMPointerType
                       (LLVMPointerType
                         (llvm-type<-type-spec context (tt (binding-term capture)))
                         0)
                       0)
                     "")))
               captures)
    ;; TODO: figure out the types of functions
    (make-term
      '?
      (llvm-build-call
        $builder
        (runtime-func "rt_make_lambda" NUC-VAL
                      (list UINTPTR (LLVMIntType 8) (LLVMIntType 32) UINTPTR))
        (list (LLVMBuildPtrToInt $builder func UINTPTR "func-pointer-to-int")
              (llvm-i8<-int arity)
              (llvm-i32<-int (length captures))
              (if (nil? captures)
                (llvm-i64<-int 0)
                (LLVMBuildPtrToInt $builder captures-array UINTPTR "array-to-int")))
        "make-lambda")
      false)))

(defun runtime-func (name return-type arg-types)
  (let ((func (LLVMGetNamedFunction $module name)))
    (if (null? func)
      (declare-function name return-type arg-types)
      func)))

(defun global-string (str)
  (LLVMBuildGEP
    $builder
    (LLVMBuildGlobalString $builder str "")
    (list (llvm-i64<-int 0) (llvm-i64<-int 0))
    2
    "str-to-ptr"))

(defun find-captured-vars (context body args)
  (unique (%find-captured-vars context body args)))

(defun %find-captured-vars (context sexpr to-ignore)
  (cond
    ((atom? sexpr)
     (if (member? sexpr to-ignore)
       nil
       (let ((binding (get-binding context sexpr)))
         (if (and (not (nil? binding))
                  (binding-lvalue? binding))
           (list binding)
           nil))))
    ((eq? (ts (car sexpr)) 'let)
     ;; Any variables introduced by let obviously aren't captures for the
     ;; duration of the let body, so we ignore them. This includes both new
     ;; variables and shadowing of old ones.
     (let ((to-ignore (append! (map (lambda (x) (ts (car (ts x))))
                                    (ts (second sexpr)))
                               to-ignore)))
       (append!
         (mappend (lambda (clause)
                    (%find-captured-vars context (ts (second (ts clause))) to-ignore))
                  (ts (second sexpr)))
         (%find-captured-vars context (cddr sexpr) to-ignore))))
    (true (mappend (lambda (e) (%find-captured-vars context (ts e) to-ignore)) sexpr))))

(defun simple-int-cmp (val1 val2)
  (make-term
    'bool
    (LLVMBuildZExt
      $builder
      (LLVMBuildICmp $builder LLVMIntEQ val1 val2 "")
      (LLVMIntType 32)
      "")
    false))
