;;; TODO: including a directory should look for 'lib' inside it
(include "llvm/lib")

;;; TODO: currently we have to put "constants" before "builtins", as there are
;;; some static initializers in "builtins" that depend on variables in
;;; "constants", and we don't currently figure out dependencies and order the
;;; initializers appropriately. This shouldn't be necessary later.
(include "constants")
(include "types")
(include "builtins")
(include "util")

(defvar $module)
(defvar $builder)

(defvar $output-debug-info)

(defun parse-args (args)
  (let ((parsed (%parse-args args (list nil))))
    (cons (reverse (car parsed)) (cdr parsed))))

(defun %parse-args (args acc)
  (if (nil? args)
    acc
    (let ((arg (first args)))
      (cond
        ((or (string-eq? arg "-ir") (string-eq? arg "-asm") (string-eq? arg "-d"))
         (set-cdr acc (cons (cons arg true) (cdr acc))))
        ((string-eq? arg "-link")
         (when (nil? (cdr args)) (panic! "'-link' must be followed by linker args"))
         (set-cdr acc (cons (cons arg (second args)) (cdr acc)))
         (set args (cdr args)))
        (true
          (set-car acc (cons arg (car acc)))))
      (%parse-args (cdr args) acc))))

(defun get-arg (args arg-name default)
  (cond ((nil? args) default)
        ((string-eq? (car (first args)) arg-name) (cdr (first args)))
        (true (get-arg (rest args) arg-name default))))

(defun main ()
  (cond
    ((not (length-is? $argv 1))
     (set $builder (LLVMCreateBuilder))
     (let* ((nucc-dir (dirname (ensure-absolute (first $argv) (current-dir))))
            (stdlib-same-dir (join-path nucc-dir "stdlib/lib.nuc"))
            (stdlib-parent-dir (join-path (join-path nucc-dir "..") "stdlib/lib.nuc"))
            (parsed-args (parse-args (rest $argv)))
            (non-flag-args (car parsed-args))
            (output-llvm-ir (get-arg parsed-args "-ir" false))
            (output-asm (get-arg parsed-args "-asm" false))
            (linker-args (string-split (get-arg parsed-args "-link" "") (list 10 32))))
       (set $output-debug-info (get-arg parsed-args "-d" false))
       (when (and output-llvm-ir output-asm)
         (panic! "Cannot specify both of '-ir' and '-asm'"))
       (let* ((input-filename (ensure-absolute (first non-flag-args) (current-dir)))
              (output-filename (if (length-is? non-flag-args 1)
                                 "a.out"
                                 (second non-flag-args)))
              (llvm-context (LLVMGetGlobalContext))
              ;; This description string is cribbed from the x86_64 target in
              ;; clang, because there is zero documentation (that I can find)
              ;; on the format of target description strings, or anything
              ;; provided for common architectures.
              (target-data (LLVMCreateTargetData
                             "e-m:e-i64:64-f80:128-n8:16:32:64-S128"))
              (context
                (make-context (copy-list $constants) nil nil target-data nil)))
         (set $module (LLVMModuleCreateWithNameInContext
                        input-filename llvm-context))
         (process-toplevel-form context '(defvar $status-code 0))
         ;; TODO: we should have a flag to not include the standard library, and
         ;; then enable it on all tests that don't need standard library functions.
         ;; That way, if the standard library is broken, only the tests that
         ;; actually use it break.
         (process-file context (list stdlib-same-dir stdlib-parent-dir))
         (process-file context (list input-filename))
         (each (lambda (f) (compile-function context (cdr f))) $functions)
         (let ((entry-point (LLVMGetNamedFunction
                              $module (mangle-name 'main)))
               (main-func (declare-function "main" INT
                                            (list INT (LLVMPointerType CHAR* 0)))))
           (when (null? entry-point)
             (panic! "No main function defined."))
           (LLVMPositionBuilderAtEnd $builder
                                     (LLVMAppendBasicBlock main-func "entry"))
           ;; Store args in $argv
           (llvm-build-call
             $builder
             (runtime-func "rt_store_argv" VOID (list INT (LLVMPointerType CHAR* 0)))
             (llvm-params main-func) "")
           (each (lambda (init)
                   (let ((var (car init))
                         (expr (cdr init)))
                     ;; TODO: statically typed globals
                     (LLVMBuildStore
                       $builder
                       (tv (coerce context (compile-expr context expr) '?))
                       var)))
                 (reverse $initialisers))
           (llvm-build-call $builder entry-point nil "")
           (LLVMBuildRet
             $builder
             (LLVMBuildIntCast
               $builder
               (LLVMBuildLShr
                 $builder
                 (LLVMBuildLoad
                   $builder (tv (binding-term (get-binding context '$status-code))) "")
                 (llvm-i64<-int LOWTAG-BITS)
                 "")
               INT
               "truncate-status-code")))
         (when (LLVMVerifyModule $module LLVMPrintMessageAction NULL)
           (LLVMDumpModule $module)
           (fail! context
                  "ICE: Module failed LLVMVerifyModule. Module has been dumped"
                  nil
                  false))
         (cond
           ((not (nil? (context-errors context)))
            (set $status-code 1)
            (format $stderr "~ errors generated:" (length (context-errors context)))
            (write-string-ln-to-stream $stderr "")
            (each (lambda (err) (write-string-ln-to-stream $stderr err))
                  (reverse (context-errors context))))
           (true
             ;; TODO: not portable
             (let ((tmp-bc-file (format nil "/tmp/~.bc" (random)))
                   (tmp-o-file (format nil "/tmp/~.o" (random))))
               (LLVMWriteBitcodeToFile $module tmp-bc-file)
               (cond
                 (output-llvm-ir
                   (let ((llvm-dis-success
                           (zero? (exec "llvm-dis"
                                        (list tmp-bc-file "-o" output-filename)))))
                     ;; TODO: Don't fork just to remove a file...
                     (exec "rm" (list tmp-bc-file))
                     (unless llvm-dis-success
                       (panic! "llvm-dis failed"))))
                 (output-asm
                   (let ((llc-success (zero? (exec "llc"
                                                   (list tmp-bc-file "-filetype=asm"
                                                         "-o" output-filename)))))
                     (exec "rm" (list tmp-bc-file))
                     (unless llc-success
                       (panic! "llc failed"))))
                 (true
                   ;; TODO: A more intelligent way of finding the runtime
                   (unless (zero? (exec "llvm-link" (list tmp-bc-file
                                                          "runtime/nuc-runtime.bc"
                                                          "-o" tmp-bc-file)))
                     (exec "rm" (list tmp-bc-file))
                     (panic! "llvm-link failed"))
                   (unless (zero? (exec "llc" (list tmp-bc-file "-filetype=obj"
                                                    "-o" tmp-o-file)))
                     (exec "rm" (list tmp-bc-file))
                     (panic! "llc failed"))
                   (unless (zero? (exec "g++" (append (list "-lm"
                                                            tmp-o-file
                                                            "-o" output-filename)
                                                      linker-args)))
                     (exec "rm" (list tmp-bc-file tmp-o-file))
                     (panic! "g++ failed"))
                   (exec "rm" (list tmp-bc-file tmp-o-file))))))))))
    (true
      (write-string-ln "Usage: nucc <input filename>"))))

(defun process-toplevel-form (context form)
  (when $output-debug-info (format true "(p-t-l .. ~)" form))
  ;; NOTE: Once we have 'defmacro' we'll need to another pass over the toplevel
  ;; forms to find 'defmacro's and compile their dependency tree
  (set form (macroexpand context form))
  (case (first form)
    ('defun
     (unless (length>= form 3)
       (fail! context (format nil "Malformed 'defun' form: ~" form) nil false))
     (let* ((name (second form))
            (arg-list (third form))
            (names-and-types (parse-arg-list context arg-list))
            (arg-names (car names-and-types))
            (arg-types
              (map (lambda (typ)
                     ;; This is kinda messy - "cons" as a type-spec is used to
                     ;; mean "any kind of cons type" when coercing (e.g.: for
                     ;; the 'car' builtin function).  However, obviously when a
                     ;; function is declared to take something of type 'cons'
                     ;; it can't take any cons type, it wants '(cons ? ?)'.
                     ;; So, we convert it here.
                     ;; TODO: We should probably come up with a different type
                     ;; spec for the 'any cons type' case.
                     (if (eq? typ 'cons) '(cons ? ?) typ))
                   (cdr names-and-types)))
            (body (cdddr form))
            (return-type (cond
                           ((and (not (nil? body)) (eq? (first body) '->))
                            (let ((t (second body)))
                              (set body (cddr body))
                              t))
                           (true '?))))
       (unless (and (symbol? name) (list? arg-list))
         (fail! context (format nil "Malformed 'defun' form: ~" form) nil false))
       (add-func context name arg-names arg-types return-type 'nucleus body)))
    ('defvar
     (when (length>= form 4)
       (fail! context (format nil "Invalid number of arguments to 'defvar' (got ~, expected 2-3)"
                              (length form))
              nil
              false))
     (let ((name (second form)))
       (if (nil? (get-binding context name))
         (let* ((value (if (length-is? form 3) (third form) 'nil))
                (init (llvm-i64<-int (if (int? value)
                                       (<< value LOWTAG-BITS)
                                       0)))
                (global (add-global context name '?)))
           (LLVMSetInitializer global init)
           (unless (int? value)
             (add-initialiser global value)))
         (fail! context (format nil "Redefinition of variable '~'" name) nil false))))
    ('extern
     (unless (length-is? (cdr form) 4)
       (fail!
         context (format nil "Invalid number of arguments to 'cfun' (got ~, expected 4)"
                         (length (cdr form)))
         nil
         false))
     (let* ((names (second form))
            (extern-name (if (cons? names) (first names) names))
            (nuc-name (if (cons? names) (second names) names))
            (arg-types (third form))
            (arity (length arg-types))
            (ret-type (fifth form))
            (llvm-func (runtime-func
                         (string<-symbol extern-name)
                         (llvm-type<-type-spec context ret-type)
                         (map (lambda (t) (llvm-type<-type-spec context t))
                              arg-types)))
            (func (make-func nuc-name arity nil arg-types
                             ret-type 'extern nil llvm-func)))
       (set $functions (cons (cons nuc-name func) $functions))))
    ('include
     (unless (length-is? (cdr form) 1)
       (fail!
         context (format nil "Invalid number of arguments to 'include' (got ~, expected 1)"
                         (length (cdr form)))
         nil
         false))
     (let* ((including-file (context-file context))
            (filename (if (string-ends-with? (second form) ".nuc")
                        (second form)
                        (string-concat (second form) ".nuc")))
            (included-file (ensure-absolute filename
                                            (dirname including-file))))
       (process-file context (list included-file))))
    ;; TODO: should this be called 'c'enum? It's just a regular enum really.
    ('cenum
     (when (nil? (cdr form))
       (fail! context "An enum must have one or more values" nil false))
     ;; TODO: support negative integer literals
     (let ((enum-variant-value (- 0 1)))
       (each
         (lambda (enum-variant)
           (let ((name (if (cons? enum-variant) (car enum-variant) enum-variant))
                 (value (set enum-variant-value
                             (if (cons? enum-variant)
                               (second enum-variant)
                               (+ 1 enum-variant-value)))))
             (LLVMSetInitializer
               (add-global context name '?)
               (fixnum<-llvm-int (llvm-i64<-int value)))))
         (cdr form))))
    (default
      (fail! context (format nil "Invalid top-level form '~'" (first form)) nil false))))

(defun process-file (context filename-and-backups)
  (let ((filename (first filename-and-backups)))
    (when $output-debug-info (format true "Processing file '~'" filename))
    (cond
      ((file-exists? filename)
       (let ((old-file (context-file context)))
         (context-set-file context filename)
         (let* ((file (open filename))
                (forms (read-all file)))
           (close file)
           (each (lambda (form) (process-toplevel-form context form)) forms))
         (context-set-file context old-file)))
      ((nil? (cdr filename-and-backups))
       (fail! context (format nil "Could not find file ~" filename) nil false))
      (true (process-file context (rest filename-and-backups))))))

(defun macroexpand (context sexpr)
  (if (and (cons? sexpr) (not (nil? sexpr)))
    (let* ((macro-name (first sexpr))
           (args (rest sexpr))
           (builtin-macro (get-builtin-macro macro-name)))
      (cond
        ((eq? macro-name 'quote) sexpr) ; don't touch quoted stuff
        ((nil? builtin-macro)
         (map (lambda (e) (macroexpand context e)) sexpr))
        ;; Call macroexpand again, as it could expand directly to another macro
        (true (macroexpand context (builtin-macro args)))))
    sexpr))

;; TODO: This is basically a subset of what compile-lambda does, we should
;; combine the two.
(defun compile-function (context func)
  (when $output-debug-info (format true "(c-f ... ~)" func))
  ;; if it's extern we don't need to compile it, the implmentation already
  ;; exists and will be found at link time
  (when (eq? (func-impl-type func) 'nucleus)
    (let* ((args (func-arg-names func))
           (original-env (context-env context))
           (llvm-func (func-llvm-func func))
           (params (llvm-params llvm-func)))
      (assert! (not (null? llvm-func)) "Function should have been declared")
      (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock llvm-func "entry"))
      ;; TODO: set LLVM param names
      (extend-env-with-terms
        context
        args
        (map2 (lambda (typ val) (make-term typ val true))
              (func-arg-types func)
              params))
      (context-set-func context func)
      (let ((compiled (LLVMBuildRet $builder
                                    (tv (coerce context
                                                (compile-progn context (func-body func))
                                                (func-return-type func))))))
        (when (LLVMVerifyFunction llvm-func LLVMPrintMessageAction)
          (LLVMDumpValue llvm-func)
          (fail!
            context
            "ICE: Function failed LLVMVerifyFunction. Function has been dumped"
            nil
            false))
        (context-set-env context original-env)
        compiled))))

(defun compile-expr (context expr)
  (when $output-debug-info (format true "(c-e ... ~)" expr))
  (let ((term (%compile-expr context expr)))
    (when $output-debug-info (format true "(c-e ... ~) -> ~" expr term))
    term))

(defun %compile-expr (context expr)
  (case (type expr)
    (fixnum-t
      (let* ((required-bits (+ 1 (int (floor (+ 1 (log2 (float expr)))))))
             (constant-type
               (cond
                 ((<= required-bits 8) 'i8)
                 ((<= required-bits 16) 'i16)
                 ((<= required-bits 32) 'i32)
                 ((<= required-bits 64) 'i64)
                 (true
                   (fail!
                     context
                     "Integer too big to fit into an i64! (How did we even read it?)"
                     '?
                     false)))))
        (make-term constant-type
                   (LLVMConstInt (llvm-type<-type-spec context constant-type)
                                 expr
                                 false)
                   false)))
    (symbol-t
      (let* ((binding (get-binding context expr))
             (term
               (cond
                 ((nil? binding)
                  (let ((func (get-func expr)))
                    (if (nil? func)
                      (fail! context (format nil "Undefined variable '~'" expr) '? true)
                      (make-lambda context
                                   (func-llvm-func func)
                                   (LLVMCountParams (func-llvm-func func))
                                   nil))))
                 (true (binding-term binding)))))
        (if (tl? term)
          (make-term
            (tt term)
            (LLVMBuildLoad $builder (tv term) (string<-symbol expr))
            false)
          term)))
    (cons-t (compile-form context expr))
    (string-t (make-term
                'string
                (llvm-build-call
                  $builder
                  (runtime-func "rt_make_string" STRING-PTR (list SIZE-T CHAR*))
                  (list (llvm-i64<-int (length expr)) (global-string expr))
                  "make-string-literal")
                false))
    (default (fail! context
                    (format nil "Don't know how to compile this type of expression: ~" expr)
                    '?
                    false))))

(defun compile-form (context form)
  (let* ((name (car form))
         (args (cdr form))
         (special-form (get-special-form name)))
    (if (not (nil? special-form))
      (special-form context args)
      (let ((builtin-function (get-builtin-function name)))
        (if (not (nil? builtin-function))
          (builtin-function context (map (lambda (arg) (compile-expr context arg)) args))
          (let ((func (get-func name)))
            (if (nil? func)
              ;; Calling a closure pointer
              ;; TODO: store RTTI in closures
              (make-term '?
                         (call-closure context (tv (compile-expr context name)) args)
                         false)
              ;; Calling a static function
              (let ((llvm-func (func-llvm-func func))
                    (arg-terms (map2 (lambda (e typ)
                                       (coerce context (compile-expr context e) typ))
                                     args
                                     (func-arg-types func))))
                (if (eq? (LLVMCountParams llvm-func) (length args))
                  (make-term
                    (func-return-type func)
                    (llvm-build-call $builder llvm-func (map tv arg-terms) "")
                    false)
                  (fail! context
                         (format nil "Invalid number of arguments to function '~' (got ~, expected ~)"
                                 name (length args) (LLVMCountParams llvm-func))
                         (func-return-type func)
                         false))))))))))
