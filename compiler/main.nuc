;;; TODO: including a directory should look for 'lib' inside it
(include "llvm/lib")

;;; TODO: currently we have to put "constants" before "builtins", as there are
;;; some static initializers in "builtins" that depend on variables in
;;; "constants", and we don't currently figure out dependencies and order the
;;; initializers appropriately. This shouldn't be necessary later.
(include "constants")
(include "types")
(include "builtins")
(include "util")

(defvar $module)
(defvar $builder)

(defvar $output-debug-info)

(defun parse-args (args)
  (let ((parsed (%parse-args args (list nil))))
    (cons (reverse (car parsed)) (cdr parsed))))

(defun %parse-args (args acc)
  (if (nil? args)
    acc
    (let ((arg (first args)))
      (cond
        ((or (string-eq? arg "-ir") (string-eq? arg "-asm") (string-eq? arg "-d"))
         (set-cdr acc (cons (cons arg true) (cdr acc))))
        ((string-eq? arg "-link")
         (when (nil? (cdr args)) (panic! "'-link' must be followed by linker args"))
         (set-cdr acc (cons (cons arg (second args)) (cdr acc)))
         (set args (cdr args)))
        (true
          (set-car acc (cons arg (car acc)))))
      (%parse-args (cdr args) acc))))

(defun get-arg (args arg-name default)
  (cond ((nil? args) default)
        ((string-eq? (car (first args)) arg-name) (cdr (first args)))
        (true (get-arg (rest args) arg-name default))))

(defun main ()
  (cond
    ((not (length-is? $argv 1))
     (set $builder (LLVMCreateBuilder))
     (let* ((nucc-dir (dirname (ensure-absolute (first $argv) (current-dir))))
            (stdlib-same-dir (join-path nucc-dir "stdlib/lib.nuc"))
            (stdlib-parent-dir (join-path (join-path nucc-dir "..") "stdlib/lib.nuc"))
            (parsed-args (parse-args (rest $argv)))
            (non-flag-args (car parsed-args))
            (output-llvm-ir (get-arg parsed-args "-ir" false))
            (output-asm (get-arg parsed-args "-asm" false))
            (linker-args (string-split (get-arg parsed-args "-link" "") (list 10 32))))
       (set $output-debug-info (get-arg parsed-args "-d" false))
       (when (and output-llvm-ir output-asm)
         (panic! "Cannot specify both of '-ir' and '-asm'"))
       (let* ((input-filename (ensure-absolute (first non-flag-args) (current-dir)))
              (output-filename (if (length-is? non-flag-args 1)
                                 "a.out"
                                 (second non-flag-args)))
              (llvm-context (LLVMGetGlobalContext))
              ;; This description string is cribbed from the x86_64 target in
              ;; clang, because there is zero documentation (that I can find)
              ;; on the format of target description strings, or anything
              ;; provided for common architectures.
              (target-data (LLVMCreateTargetData
                             "e-m:e-i64:64-f80:128-n8:16:32:64-S128"))
              (context
                (make-context (copy-list $constants) nil nil target-data nil)))
         (set $module (LLVMModuleCreateWithNameInContext
                        input-filename llvm-context))
         (process-toplevel-form context (dummy-token (map dummy-token
                                                          '(defvar $status-code 0))))
         ;; TODO: we should have a flag to not include the standard library, and
         ;; then enable it on all tests that don't need standard library functions.
         ;; That way, if the standard library is broken, only the tests that
         ;; actually use it break.
         (process-file context $dummy-source-loc (list stdlib-same-dir stdlib-parent-dir))
         (process-file context $dummy-source-loc (list input-filename))
         (each (lambda (f) (compile-function context (cdr f))) $functions)
         (let ((entry-point (LLVMGetNamedFunction
                              $module (mangle-name 'main)))
               (main-func (declare-function "main" INT
                                            (list INT (LLVMPointerType CHAR* 0)))))
           (when (null? entry-point)
             (panic! "No main function defined."))
           (LLVMPositionBuilderAtEnd $builder
                                     (LLVMAppendBasicBlock main-func "entry"))
           ;; Store args in $argv
           (llvm-build-call
             $builder
             (runtime-func "rt_store_argv" VOID (list INT (LLVMPointerType CHAR* 0)))
             (llvm-params main-func) "")
           (each (lambda (init)
                   (let ((var (car init))
                         (expr (cdr init)))
                     ;; TODO: statically typed globals
                     (LLVMBuildStore
                       $builder
                       (tv (coerce context (compile-expr context expr) '?
                                   (token-source-loc expr)))
                       var)))
                 (reverse $initialisers))
           (llvm-build-call $builder entry-point nil "")
           (LLVMBuildRet
             $builder
             (LLVMBuildIntCast
               $builder
               (LLVMBuildLShr
                 $builder
                 (LLVMBuildLoad
                   $builder (tv (binding-term (get-binding context '$status-code))) "")
                 (llvm-i64<-int LOWTAG-BITS)
                 "")
               INT
               "truncate-status-code")))
         (when (LLVMVerifyModule $module LLVMPrintMessageAction NULL)
           (LLVMDumpModule $module)
           (fail! context
                  "ICE: Module failed LLVMVerifyModule. Module has been dumped"
                  $dummy-source-loc
                  nil false))
         (cond
           ((not (nil? (context-errors context)))
            (set $status-code 1)
            (format $stderr "~ error(s) generated:" (length (context-errors context)))
            (write-string-ln-to-stream $stderr "")
            (each (lambda (err)
                    (let* ((source-loc (error-source-loc err))
                           (filename (source-loc-source-name source-loc))
                           (filename-to-report
                             (if (absolute-path? filename)
                               (let ((str (string-strip-prefix
                                            filename (dirname filename))))
                                 (substring str 1 (string-length str)))
                               filename)))
                      (write-string-to-stream $stderr filename-to-report)
                      (format $stderr ":~:~ "
                              (source-loc-line source-loc)
                              (source-loc-col source-loc))
                      (write-string-to-stream $stderr "in ")
                      (write-string-to-stream $stderr (error-source-context err))
                      (write-string-ln-to-stream $stderr ":")
                      (write-string-to-stream $stderr "    ")
                      (write-string-ln-to-stream $stderr (error-message err))
                      (write-string-ln-to-stream $stderr "")))
                  (reverse (context-errors context))))
           (true
             ;; TODO: not portable
             (let ((tmp-bc-file (format nil "/tmp/~.bc" (random)))
                   (tmp-o-file (format nil "/tmp/~.o" (random))))
               (LLVMWriteBitcodeToFile $module tmp-bc-file)
               (cond
                 (output-llvm-ir
                   (let ((llvm-dis-success
                           (zero? (exec "llvm-dis"
                                        (list tmp-bc-file "-o" output-filename)))))
                     ;; TODO: Don't fork just to remove a file...
                     (exec "rm" (list tmp-bc-file))
                     (unless llvm-dis-success
                       (panic! "llvm-dis failed"))))
                 (output-asm
                   (let ((llc-success (zero? (exec "llc"
                                                   (list tmp-bc-file "-filetype=asm"
                                                         "-o" output-filename)))))
                     (exec "rm" (list tmp-bc-file))
                     (unless llc-success
                       (panic! "llc failed"))))
                 (true
                   ;; TODO: A more intelligent way of finding the runtime
                   (unless (zero? (exec "llvm-link" (list tmp-bc-file
                                                          "runtime/nuc-runtime.bc"
                                                          "-o" tmp-bc-file)))
                     (exec "rm" (list tmp-bc-file))
                     (panic! "llvm-link failed"))
                   (unless (zero? (exec "llc" (list tmp-bc-file "-filetype=obj"
                                                    "-o" tmp-o-file)))
                     (exec "rm" (list tmp-bc-file))
                     (panic! "llc failed"))
                   (unless (zero? (exec "g++" (append (list "-lm"
                                                            tmp-o-file
                                                            "-o" output-filename)
                                                      linker-args)))
                     (exec "rm" (list tmp-bc-file tmp-o-file))
                     (panic! "g++ failed"))
                   (exec "rm" (list tmp-bc-file tmp-o-file))))))))))
    (true
      (write-string-ln "Usage: nucc <input filename>"))))

(defun process-toplevel-form (context token)
  (when $output-debug-info (format true "(p-t-f .. ~)" token))
  ;; NOTE: Once we have 'defmacro' we'll need to another pass over the toplevel
  ;; forms to find 'defmacro's and compile their dependency tree
  (let* ((token (macroexpand context token))
         (form (ts token)))
    (case (ts (first form))
      ('defun
       (when $output-debug-info (write-string-ln "processing defun"))
       (unless (length>= form 3)
         (fail! context "Not enough args to 'defun'" (token-source-loc token) nil false))
       (let* ((name (second form))
              (arg-list (third form))
              (names-and-types (parse-arg-list context arg-list))
              (arg-names (car names-and-types))
              (arg-types
                (map (lambda (typ)
                       ;; This is kinda messy - "cons" as a type-spec is used to
                       ;; mean "any kind of cons type" when coercing (e.g.: for
                       ;; the 'car' builtin function).  However, obviously when a
                       ;; function is declared to take something of type 'cons'
                       ;; it can't take any cons type, it wants '(cons ? ?)'.
                       ;; So, we convert it here.
                       ;; TODO: We should probably come up with a different type
                       ;; spec for the 'any cons type' case.
                       (if (eq? typ 'cons) '(cons ? ?) typ))
                     (cdr names-and-types)))
              (body (cdddr form))
              (return-type-token (cond
                                   ((and (not (nil? body))
                                         (eq? (ts (first body)) '->))
                                    (let ((t (second body)))
                                      (set body (cddr body))
                                      t))
                                   (true (dummy-token '?))))
              (return-type (ts return-type-token))
              (return-type-source-loc (token-source-loc return-type-token)))
         (unless (symbol? (ts name))
           (fail! context
                  (format nil "Function name must be a string: ~" (ts name))
                  (token-source-loc name)
                  nil false))
         (unless (list? arg-list)
           (fail! context
                  (format nil "Argument list must be a list: ~" (ts arg-list))
                  (token-source-loc arg-list)
                  nil false))
         (if (any? generic-type? (cons return-type arg-types))
           (add-generic-func context (ts name) arg-names arg-types return-type
                             return-type-source-loc body)
           (add-func context (ts name) arg-names arg-types return-type 'nucleus body))))
      ('defvar
       (when (length>= form 4)
         (fail! context (format nil "Invalid number of arguments to 'defvar' (got ~, expected 2-3)"
                                (length form))
                (token-source-loc token)
                nil false))
       (let ((name (second form)))
         (if (nil? (get-binding context (ts name)))
           (let* ((value (if (length-is? form 3) (third form) (dummy-token 'nil)))
                  (init (llvm-i64<-int (if (int? (ts value))
                                         (<< (ts value) LOWTAG-BITS)
                                         0)))
                  (global (add-global context name '?)))
             (LLVMSetInitializer global init)
             (unless (int? (ts value))
               (add-initialiser global value)))
           (fail! context
                  (format nil "Redefinition of variable '~'" (ts name))
                  (token-source-loc name)
                  nil false))))
      ('extern
       (unless (length-is? (cdr form) 4)
         (fail!
           context
           (format nil "Invalid number of arguments to 'extern' (got ~, expected 4)"
                   (length (cdr form)))
           (token-source-loc (first form))
           nil false))
       ;; TODO: Shouldn't this use add-func?
       (let* ((names (ts (second form)))
              (extern-name (if (cons? names) (ts (first names)) names))
              (nuc-name (if (cons? names) (ts (second names)) names))
              (arg-types (map remove-tokens-from-type (ts (third form))))
              (arity (length arg-types))
              (ret-type (ts (fifth form)))
              (llvm-func (runtime-func
                           (string<-symbol extern-name)
                           (llvm-type<-type-spec context ret-type)
                           (map (lambda (t) (llvm-type<-type-spec context t))
                                arg-types)))
              (func (make-func nuc-name arity nil arg-types
                               ret-type 'extern nil llvm-func)))
         (set $functions (cons (cons nuc-name func) $functions))))
      ('include
       (unless (length-is? (cdr form) 1)
         (fail!
           context
           (format nil "Invalid number of arguments to 'include' (got ~, expected 1)"
                   (length (cdr form)))
           (token-source-loc token)
           nil false))
       (let* ((including-file (context-file context))
              (filename (if (string-ends-with? (ts (second form)) ".nuc")
                          (ts (second form))
                          (string-concat (ts (second form)) ".nuc")))
              (included-file (ensure-absolute filename
                                              (dirname including-file))))
         (process-file context (token-source-loc (first form)) (list included-file))))
      ;; TODO: should this be called 'c'enum? It's just a regular enum really.
      ('cenum
       (when (nil? (cdr form))
         (fail! context "An enum must have one or more values"
                (token-source-loc token) nil false))
       ;; TODO: support negative integer literals
       (let ((enum-variant-value (- 0 1)))
         (each
           (lambda (enum-variant)
             (let ((name (if (cons? (ts enum-variant))
                           (car (ts enum-variant))
                           enum-variant))
                   (value (set enum-variant-value
                               (if (cons? (ts enum-variant))
                                 (ts (second (ts enum-variant)))
                                 (+ 1 enum-variant-value)))))
               (LLVMSetInitializer
                 (add-global context name '?)
                 (fixnum<-llvm-int (llvm-i64<-int value)))))
           (cdr form))))
      (default
        (fail! context (format nil "Invalid top-level form '~'" (ts (first form)))
               (token-source-loc (first form))
               nil false)))))

(defun process-file (context source-loc filename-and-backups)
  (let ((filename (first filename-and-backups)))
    (when $output-debug-info (format true "Processing file '~'" filename))
    (cond
      ((file-exists? filename)
       (let ((old-file (context-file context)))
         (context-set-file context filename)
         (let* ((file (open filename))
                (forms (read-all-with-source-loc file)))
           (close file)
           (each (lambda (form) (process-toplevel-form context form)) forms))
         (context-set-file context old-file)))
      ((nil? (cdr filename-and-backups))
       (fail! context
              (format nil "Could not find file ~" filename)
              source-loc
              nil false))
      (true (process-file context source-loc (rest filename-and-backups))))))

(defun macroexpand (context token)
  (let ((sexpr (ts token)))
    (if (and (cons? sexpr) (not (nil? sexpr)))
      (let* ((macro-name (ts (first sexpr)))
             (args (rest sexpr))
             (builtin-macro (get-builtin-macro macro-name)))
        (cond
          ((eq? macro-name 'quote) token) ; don't touch quoted stuff
          ((nil? builtin-macro)
           (copy-source-loc token
                            (map (lambda (e) (macroexpand context e)) sexpr)))
          ;; Call macroexpand again, as it could expand directly to another macro
          (true (macroexpand context (copy-source-loc token (builtin-macro context args))))))
      token)))

(defun compile-function (context func)
  (when $output-debug-info (format true "(c-func ... ~)" func))
  ;; if it's extern we don't need to compile it, the implmentation already
  ;; exists and will be found at link time
  (when (eq? (func-impl-type func) 'nucleus)
    (context-set-func context func)
    (%compile-function
      context (func-arg-names func) (func-arg-types func)
      (func-return-type func) (func-body func) (func-llvm-func func))))

(defun compile-generic-function-impl (context generic-func concrete-arg-types
                                              concrete-ret-type)
  (when $output-debug-info
    (format true "(c-g-f-i ... ~ ~ ~)"
            generic-func concrete-arg-types concrete-ret-type))
  ;; TODO: change context-func to a string, so we can set from here
  (let ((llvm-func (declare-function
                     (mangle-generic-func-name
                       (generic-func-name generic-func) concrete-arg-types concrete-ret-type)
                     (llvm-type<-type-spec context concrete-ret-type)
                     (map (lambda (t) (llvm-type<-type-spec context t))
                          concrete-arg-types))))
    (%compile-function
      context
      (generic-func-arg-names generic-func)
      concrete-arg-types
      concrete-ret-type
      (generic-func-body generic-func)
      llvm-func)
    llvm-func))

;; TODO: This is basically a subset of what compile-lambda does, we should
;; combine the two.
(defun %compile-function (context arg-names arg-types return-type body llvm-func)
  (let* ((original-block (LLVMGetInsertBlock $builder))
         (original-env (context-env context))
         (params (llvm-params llvm-func)))
      (assert! (not (null? llvm-func)) "Function should have been declared")
      (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock llvm-func "entry"))
      ;; TODO: set LLVM param names
      (extend-env-with-terms
        context
        arg-names
        (map2 (lambda (typ val) (make-term typ val true)) arg-types params))
      (LLVMBuildRet
        $builder
        (tv (coerce
              context
              (compile-progn context body)
              return-type
              (token-source-loc
                (if (nil? body)
                  ;; TODO: track source loc
                  ;; of the defun form itself
                  $dummy-source-loc
                  (car (last body)))))))
      (unless (null? original-block) ; if we weren't in a block before it's null
        (LLVMPositionBuilderAtEnd $builder original-block))
      (context-set-env context original-env)
      (when (LLVMVerifyFunction llvm-func LLVMPrintMessageAction)
        (LLVMDumpValue llvm-func)
        (fail!
          context
          "ICE: Function failed LLVMVerifyFunction. Function has been dumped"
          $dummy-source-loc ; TODO: track source loc in 'func's
          nil false))))

(defun compile-expr (context expr)
  (when $output-debug-info
    (format true "(c-e ... ~)" expr))
  (let ((term (%compile-expr context expr)))
    (when $output-debug-info
      (format true "(c-e ... ~) -> ~" expr term))
    term))

(defun %compile-expr (context token)
  (let ((expr (ts token)))
    (case (type expr)
      (fixnum-t
        (let* ((required-bits (+ 1 (int (floor (+ 1 (log2 (float expr)))))))
               (constant-type
                 (cond
                   ((<= required-bits 8) 'i8)
                   ((<= required-bits 16) 'i16)
                   ((<= required-bits 32) 'i32)
                   ((<= required-bits 64) 'i64)
                   (true
                     (fail!
                       context
                       "Integer too big to fit into an i64! (How did we even read it?)"
                       (token-source-loc token)
                       '?  false)))))
          (make-term constant-type
                     (LLVMConstInt (llvm-type<-type-spec context constant-type)
                                   expr
                                   false)
                     false)))
      (symbol-t
        (let* ((binding (get-binding context expr))
               (term
                 (if (not (nil? binding))
                   (binding-term binding)
                   (let ((func (get-func expr)))
                     (if (nil? func)
                       (fail! context
                              (format nil "Undefined variable '~'" expr)
                              (token-source-loc token)
                              '? true)
                       (make-lambda context
                                    (func-llvm-func func)
                                    (func-arg-types func)
                                    (func-return-type func)
                                    nil))))))
          (if (tl? term)
            (make-term
              (tt term)
              (LLVMBuildLoad $builder (tv term) (string<-symbol expr))
              false)
            term)))
      (cons-t (compile-form context token))
      (string-t (make-term
                  'string
                  (llvm-build-call
                    $builder
                    (runtime-func "rt_make_string" STRING-PTR (list SIZE-T CHAR*))
                    (list (llvm-i64<-int (length expr)) (global-string expr))
                    "make-string-literal")
                  false))
      (default (fail! context
                      (format nil "Don't know how to compile this type of expression: ~" expr)
                      (token-source-loc token)
                      '?  false)))))

(defun compile-form (context token)
  (let* ((form (ts token))
         (name (car form))
         (args (cdr form))
         (arity (length args))
         (special-form (get-special-form (ts name))))
    (if (not (nil? special-form))
      (special-form context args)
      (let ((builtin-function (get-builtin-function (ts name))))
        (if (not (nil? builtin-function))
          (builtin-function
            context
            (map (lambda (arg) (compile-expr context arg)) args))
          (let ((func (get-func (ts name))))
            (if (nil? func)
              (let ((generic-func (get-generic-func (ts name))))
                (if (nil? generic-func)
                  ;; Calling a closure pointer
                  (let ((closure-term
                          (coerce context
                                  (compile-expr context name)
                                  (list 'any-func arity)
                                  (token-source-loc token))))
                    (make-term
                      (func-type-return-type (tt closure-term))
                      (call-closure context closure-term
                                    (map (lambda (arg)
                                           (compile-expr context arg))
                                         args)
                                    false)
                      false))
                  ;; Calling a generic function
                  (if (not (eq? arity (generic-func-arity generic-func)))
                    (fail! context
                           (format nil "Invalid number of arguments to generic function '~' (got ~, expected ~)"
                                   (ts name)
                                   arity
                                   (generic-func-arity generic-func))
                           (token-source-loc token)
                           (generic-func-return-type generic-func) false)
                    (let* ((arg-terms (map (lambda (arg-token)
                                             (compile-expr context arg-token))
                                           args))
                           (concrete-types (get-concrete-types
                                                 context generic-func arg-terms))
                           (ret-type (car concrete-types))
                           (required-arg-types (cdr concrete-types))
                           (coerced-args
                             (map (lambda (c)
                                    (let ((arg-term (car c))
                                          (required-type (cadr c))
                                          (source-loc (cddr c)))
                                      (coerce context arg-term required-type
                                              source-loc)))
                                  (zip arg-terms
                                       (zip required-arg-types
                                            (map token-source-loc args)))))
                           (llvm-func (get-generic-func-specialization
                                        context generic-func required-arg-types
                                        ret-type (token-source-loc token))))
                      (make-term
                        ret-type
                        (llvm-build-call $builder llvm-func (map tv coerced-args) "")
                        false)))))
              ;; Calling a static function
              (let* ((llvm-func (func-llvm-func func))
                     (arg-terms (map2 (lambda (e typ)
                                        (coerce context
                                                (compile-expr context e)
                                                typ
                                                (token-source-loc e)))
                                      args
                                      (func-arg-types func))))
                (if (eq? (LLVMCountParams llvm-func) arity)
                  (make-term
                    (func-return-type func)
                    (llvm-build-call $builder llvm-func (map tv arg-terms) "")
                    false)
                  (fail! context
                         (format nil "Invalid number of arguments to function '~' (got ~, expected ~)"
                                 (ts name) arity (LLVMCountParams llvm-func))
                         (token-source-loc token)
                         (func-return-type func) false))))))))))
