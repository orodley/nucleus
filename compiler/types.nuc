;;; A 'term' is the compile-time form of a nucleus value. It has a corresponding
;;; LLVMValueRef, type, and boolean indicating whether it is an lvalue (i.e.
;;; can be assigned to). If the type is unknown, it defaults to ?, the dynamic
;;; type.
;;; TODO: Replace with a struct once they exist
;;; TODO: It could be really useful to keep track of known null vs. non-null
;;; information about cons terms, to avoid some runtime checks. Sometimes we
;;; literally just allocated the thing so those cases are easy pickings.
(defun make-term (typ val lvalue?)
  (assert! (eq? (type val) foreign-t)
           (format nil "val should be an llvm ValueRef (got ~)" val))
  (assert! (or (symbol? typ) (cons? typ)) "typ should be a type-spec")
  (assert! (or (eq? lvalue? true) (eq? lvalue? false)) "lvalue? should be a bool")
  (list typ val lvalue?))
(defun tt (term) (first term))
(defun tv (term) (second term))
(defun tl? (term) (third term))

(defun coerce (context term typ blame-source-loc)
  (when $output-debug-info (format true "(coerce ... ~ ~)" term typ))
  (cond
    ((type-eq? (tt term) typ) term)
    ((type-eq? (tt term) '?)
     (make-term typ
                (static-val<-dynamic-val context typ (tv term) blame-source-loc)
                (tl? term)))
    ((type-eq? typ '?)
     (make-term typ
                (dynamic-val<-static-val context (tt term) (tv term) blame-source-loc)
                (tl? term)))
    (true
      (make-term typ
                 (implicit-conversion context term typ blame-source-loc)
                 (tl? term)))))

;; TODO: I think there are a few cases where an ad-hoc version of this was
;; used inline which should now be using this instead.
(defun compatible? (given-type desired-type)
  (or (type-eq? given-type desired-type)
      (type-eq? given-type '?)
      (type-eq? desired-type '?)
      (and (integral? given-type) (numeric? desired-type))))

;; TODO: append "-type"

(defun numeric? (typ) (or (integral? typ) (floating-point? typ)))

(defun integral? (typ)
  (member? typ '(int uint long long-long char
                 u8 i8 i16 i32 i64)))

(defun floating-point? (typ)
  (type-eq? typ 'float))

(defun cons-type? (typ)
  (or (eq? typ 'cons)
      (and (cons? typ)
           (or (eq? (first typ) 'cons)
               (eq? (first typ) 'list-of)))))

(defun list-type? (typ) (and (cons? typ) (eq? (first typ) 'list-of)))

(defun func-type? (typ)
  (and (cons? typ) (or (eq? (first typ) 'any-func) (eq? (first typ) 'func))))

(defun type-eq? (t1 t2)
  (or (eq? t1 t2)
      (and (cons-type? t1) (cons-type? t2)
           (or (eq? t1 'cons) (eq? t2 'cons)
               (and (eq? (first t1) 'list-of) (eq? (first t2) 'list-of)
                    (type-eq? (second t1) (second t2)))
               (and (type-eq? (second t1) (second t2))
                    (type-eq? (third t1) (third t2)))))
      (and (func-type? t1) (func-type? t2)
           (eq? (func-type-arity t1) (func-type-arity t2))
           (or (eq? (car t1) 'any-func) (eq? (car t2) 'any-func)
               (and (all? (lambda (c) (type-eq? (car c) (cdr c)))
                          (zip (func-type-arg-types t1) (func-type-arg-types t2)))
                    (type-eq? (func-type-return-type t1) (func-type-return-type t2)))))
      (and (eq? t1 'int) (eq? t2 'i32))
      (and (eq? t2 'int) (eq? t1 'i32))))

(defun car-type (typ)
  (expand-type (if (or (eq? typ 'cons) (eq? typ '?)) '? (second typ))))
(defun cdr-type (typ)
  (expand-type (cond
                 ((or (eq? typ 'cons) (eq? typ '?)) '?)
                 ((eq? (first typ) 'list-of) typ)
                 (true (third typ)))))

(defun func-type-arity (type-spec)
  (if (eq? (first type-spec) 'any-func)
    (second type-spec)
    (length (second type-spec))))

;; TODO: Check we're using these everywhere we should
(defun func-type-arg-types (type-spec)
  (if (eq? (first type-spec) 'any-func)
    (repeat (second type-spec) '?)
    (second type-spec)))

(defun func-type-return-type (type-spec)
  (if (eq? (first type-spec) 'any-func)
    '?
    (fourth type-spec)))

(defun i64<-term (context term)
  (case (LLVMGetTypeKind (llvm-type<-type-spec context (tt term)))
    (LLVMPointerTypeKind (LLVMBuildPtrToInt $builder (tv term) NUC-VAL ""))
    (LLVMIntegerTypeKind (LLVMBuildIntCast $builder (tv term) NUC-VAL ""))
    (default (fail! context
                    (format nil "i64<-term not implemented for ~" (tt term))
                    $dummy-source-loc ; TODO: better source loc
                    NUC-VAL false))))

(defun term<-i64 (context val dest-type)
  (let ((llvm-type (llvm-type<-type-spec context dest-type)))
    (case (LLVMGetTypeKind llvm-type)
      (LLVMPointerTypeKind (LLVMBuildIntToPtr $builder val llvm-type ""))
      (LLVMIntegerTypeKind (LLVMBuildIntCast $builder val llvm-type ""))
      (default (fail! context
                      (format nil "term<-i64 not implemented for ~" dest-type)
                      $dummy-source-loc ; TODO: better source loc
                      llvm-type false)))))

(defun expand-type (typ)
  (if (eq? typ 'cons)
    (list 'cons '? '?)
    typ))

(defun guarded-ref<-static-cons (context cons-ptr src-type dest-type blame-source-loc)
  (assert! (and (cons-type? src-type) (cons-type? dest-type))
           "src-type and dest-type must be cons types")
  (let ((convert-car? (not (type-eq? (car-type src-type) (car-type dest-type))))
        (convert-cdr? (not (type-eq? (cdr-type src-type) (cdr-type dest-type)))))
    (when $output-debug-info
      (format true "(g-r<-s-c ... ~ ~)" cons-ptr src-type dest-type))
    (cond
      ((not (or convert-car? convert-cdr?)) cons-ptr)
      ((LLVMIsConstant cons-ptr)
       ;; Don't bother checking at runtime if we know it's null at compile-time
       (LLVMConstNull CONS-CELL-PTR))
      (true
        (let* ((current-func (get-current-func $builder))
               (before-block (LLVMGetInsertBlock $builder))
               (non-nil-block (LLVMAppendBasicBlock current-func "non-nil-static-cons"))
               (after-block (LLVMAppendBasicBlock current-func "after-static-cons")))
          (assert! (or convert-car? convert-cdr?) "Shouldn't have gotten called if the types are already correct")
          (LLVMBuildCondBr
            $builder
            (LLVMBuildICmp $builder LLVMIntEQ cons-ptr (LLVMConstNull CONS-CELL-PTR) "")
            after-block non-nil-block)
          (LLVMPositionBuilderAtEnd $builder non-nil-block)
          (when convert-car?
            (let* ((car-value
                     (term<-i64 context (get-car-value cons-ptr) (car-type src-type)))
                   (coerced-car
                     (coerce context (make-term (car-type src-type) car-value false) '?
                             blame-source-loc)))
              (set-car-value cons-ptr (i64<-term context coerced-car))))
          (when convert-cdr?
            (let* ((cdr-value
                     (term<-i64 context (get-cdr-value cons-ptr) (cdr-type src-type)))
                   (coerced-cdr
                     (coerce context (make-term (cdr-type src-type) cdr-value false) '?
                             blame-source-loc)))
              (set-cdr-value cons-ptr (i64<-term context coerced-cdr))))
          (set-gr-value cons-ptr
                        (LLVMBuildOr $builder (get-gr-value cons-ptr)
                                     (llvm-i8<-int
                                       (cond
                                         ((and convert-car? convert-cdr?) 3)
                                         (convert-car? 2)
                                         (convert-cdr? 1)))
                                     ""))
          (LLVMBuildBr $builder after-block)
          (LLVMPositionBuilderAtEnd $builder after-block)
          cons-ptr)))))

(defun convert-list (cons-val convert get-next)
  (let* ((current-func (get-current-func $builder))
         (before-block (LLVMGetInsertBlock $builder))
         (loop-entry (LLVMAppendBasicBlock current-func "convert-list-entry"))
         (loop-body (LLVMAppendBasicBlock current-func "convert-list-body"))
         (after-block (LLVMAppendBasicBlock $builder "after-convert-list")))
    (LLVMPositionBuilderAtEnd $builder loop-entry)
    (let* ((current-cons (LLVMBuildPhi $builder (LLVMTypeOf cons-val) "current-cons"))
           (current-cons-ptr (get-next current-cons)))
      (LLVMAddIncoming current-cons (list cons-val) (list before-block) 1)
      (LLVMBuildCondBr
        $builder
        (LLVMBuildICmp $builder LLVMIntEQ LLVM-NULL-CONS current-cons-ptr "nil?")
        after-block
        loop-body)
      (LLVMPositionBuilderAtEnd $builder loop-body)
      (let ((cdr-value (get-cdr-value current-cons-ptr)))
        (convert current-cons-ptr)
        (LLVMAddIncoming current-cons (list cdr-value) (list (LLVMGetInsertBlock $builder)) 1))
      (LLVMBuildBr $builder loop-entry))
    (LLVMPositionBuilderAtEnd $builder after-block))
  cons-val)

(defun type-size (context typ)
  (LLVMGetIntTypeWidth (llvm-type<-type-spec context typ)))

(defun remove-lowtag (val)
  (LLVMBuildAnd $builder val
                ;; This is (~ (- (<< 1 LOWTAG-BITS) 1)).
                ;; We can't write that directly as it exceeds the 61-bit limit
                ;; of nucleus fixnums
                (LLVMConstIntOfString (LLVMIntType 64) "fffffffffffffff8" 16)
                "remove-lowtag"))

;;; TODO: rework some of this stuff

(defun add-lowtag (val tag)
  (LLVMBuildOr $builder
               (LLVMBuildPtrToInt $builder val NUC-VAL "ptr-to-int")
               (llvm-i64<-int tag) "add-lowtag"))

(defun fixnum<-llvm-int (val)
  (add-lowtag (LLVMBuildShl $builder val (llvm-i64<-int LOWTAG-BITS) "")
              FIXNUM-LOWTAG))

(defun check-type (val type-as-llvm-val)
  (llvm-build-call
    $builder
    (runtime-func "rt_check_type" VOID (list NUC-VAL NUC-VAL))
    (list val type-as-llvm-val)
    ""))

(defun llvm-i64<-int (x) (LLVMConstInt (LLVMIntType 64) x false))
(defun llvm-i32<-int (x) (LLVMConstInt (LLVMIntType 32) x false))
(defun llvm-i8<-int (x) (LLVMConstInt (LLVMIntType 8) x false))

;;; TODO: this should probably have an extra phase - converting into a nucleus
;;; type object.

;; TODO: This should have a way of taking a token for the type spec, so we can
;; blame the user when they enter an incorrect type
(defun llvm-type<-type-spec (context type-spec)
  (if (cons? type-spec)
    (case (first type-spec)
      ('cons CONS-CELL-PTR)
      ('list-of CONS-CELL-PTR)
      ('func CLOSURE-PTR)
      (default
        (fail! context (format nil "Unsupported compound type '~'"
                               (first type-spec))
               $dummy-source-loc ; TODO: better source loc
               nil false)
        NUC-VAL))
    (case type-spec
      ;; FFI stuff
      ('* UINTPTR)
      ('char (LLVMIntType 8))
      ('char* CHAR*)
      ('void VOID)
      ('int INT) ('uint INT) ('bool INT)
      ('long LONG)
      ('long-long LONG-LONG)
      ('array (LLVMPointerType UINTPTR 0))

      ;; Fixed width integer types.
      ;; TODO: We need to do unsigned types properly.
      ('u8 (LLVMIntType 8))
      ('i8 (LLVMIntType 8))
      ('i16 (LLVMIntType 16))
      ('i32 (LLVMIntType 32))
      ('i64 (LLVMIntType 64))

      ;; Primitive nucleus types
      ('? NUC-VAL)
      ('symbol (LLVMIntType 32))
      ('bool (LLVMIntType 32))
      ('string STRING-PTR)
      ('cons CONS-CELL-PTR)
      ('float (LLVMFloatType))

      (default
        (fail! context
               (format nil "Unsupported type-spec for llvm-type<-type-spec '~'" type-spec)
               $dummy-source-loc ; TODO: better source loc
               nil false)
        NUC-VAL))))

(defun type-id<-type-spec (context type-spec)
  (case type-spec
    ;; FFI stuff
    ('* LLVM-FOREIGN-T)
    ('char* LLVM-STRING-T)
    ;; TODO: We arbitrarily make calls to void functions evaluate to nil, so
    ;; void = cons. Should we make them be something else? A special purpose
    ;; value which isn't allowed to be used maybe?
    ('void LLVM-CONS-T)
    ('int LLVM-FIXNUM-T) ('uint LLVM-FIXNUM-T) ('long-long LLVM-FIXNUM-T)
    ('uint8 LLVM-FIXNUM-T) ('u8 LLVM-FIXNUM-T) ('i8 LLVM-FIXNUM-T)
    ('i32 LLVM-FIXNUM-T) ('i64 LLVM-FIXNUM-T)

    ;; Primitive nucleus types
    ('symbol LLVM-SYMBOL-T)
    ('bool LLVM-BOOL-T)
    ('string LLVM-STRING-T)
    ('cons LLVM-CONS-T)

    (default
      (fail! context
             (format nil "Unsupported type-spec for type-id<-type-spec '~'" type-spec)
             $dummy-source-loc ; TODO: better source loc
             nil false)
      LLVM-CONS-T)))

(defun static-val<-dynamic-val (context type-spec val blame-source-loc)
  (cond
    ((type-eq? type-spec '*)
     (check-type val LLVM-FOREIGN-T)
     (LLVMBuildIntToPtr
       $builder
       (LLVMBuildLoad
         $builder
         (LLVMBuildIntToPtr
           $builder (remove-lowtag val) (LLVMPointerType NUC-VAL 0) "")
         "")
       UINTPTR
       ""))
    ((type-eq? type-spec 'char*)
     (check-type val LLVM-STRING-T)
     (llvm-build-call
       $builder
       (runtime-func "rt_nuc_str_to_c_str" CHAR* (list NUC-VAL))
       (list val) "static-val<-dynamic-val"))
    ((integral? type-spec)
     (check-type val LLVM-FIXNUM-T)
     (LLVMBuildIntCast
       $builder
       (LLVMBuildAShr $builder val (llvm-i64<-int LOWTAG-BITS) "remove-int-tag")
       (llvm-type<-type-spec context type-spec)
       ""))
    ((floating-point? type-spec)
     (check-type val LLVM-FLOAT-T)
     (LLVMBuildBitCast
       $builder
       (LLVMBuildIntCast
         $builder
         (LLVMBuildLShr $builder val (llvm-i64<-int (+ LOWTAG-BITS EXTTAG-BITS)) "")
         (LLVMIntType 32)
         "")
       (llvm-type<-type-spec context type-spec)
       ""))
    ((type-eq? type-spec 'bool)
     (check-type val LLVM-BOOL-T)
     (LLVMBuildSelect $builder (LLVMBuildICmp $builder LLVMIntEQ val LLVM-TRUE "")
                      (llvm-i32<-int 1) (llvm-i32<-int 0) ""))
    ((type-eq? type-spec 'string)
     (check-type val LLVM-STRING-T)
     (LLVMBuildIntToPtr $builder (remove-lowtag val) STRING-PTR ""))
    ((type-eq? type-spec 'array)
     (check-type val LLVM-CONS-T)
     (llvm-build-call
       $builder
       (runtime-func "rt_list_to_array" (llvm-type<-type-spec context type-spec) (list NUC-VAL))
       (list val)
       "array<-list"))
    ((type-eq? type-spec 'symbol)
     (check-type val LLVM-SYMBOL-T)
     (LLVMBuildIntCast
       $builder
       (LLVMBuildLShr $builder val (llvm-i64<-int LOWTAG-BITS) "remove-symbol-lowtag")
       (llvm-type<-type-spec context type-spec)
       ""))
    ((list-type? type-spec)
     (let* ((list-elem-type (car-type type-spec))
            (elem-type-id (type-id<-type-spec context list-elem-type)))
       (convert-list
         val
         (lambda (cons-ptr)
           (check-type (get-car-value cons-ptr) elem-type-id)
           (set-gr-value cons-ptr 3))
         (lambda (cons-val)
           (check-type cons-val LLVM-CONS-T)
           (remove-lowtag cons-val))))
     (remove-lowtag val))
    ((cons-type? type-spec)
     ;; To convert a cons containing dynamically typed values into a statically
     ;; typed cons, we just set the guarded reference flag, and leave the
     ;; values contained unconverted. This is necessary because there could be
     ;; references to this cons which expect it to contain dynamically typed
     ;; values. It is complicated by the fact that the cons could be nil - in
     ;; that case we can't set the flag, we just pass on the nil value.
     (check-type val LLVM-CONS-T)
     (if (LLVMIsConstant val)
       (LLVMConstNull CONS-CELL-PTR)
       (let* ((current-func (get-current-func $builder))
              (cons-ptr (LLVMBuildIntToPtr $builder (remove-lowtag val)
                                           CONS-CELL-PTR ""))
              (non-nil-block (LLVMAppendBasicBlock current-func "add-gr-flag-non-nil-cons"))
              (after-block (LLVMAppendBasicBlock current-func "add-gr-flag-after")))
       (LLVMBuildCondBr
         $builder
         (LLVMBuildICmp $builder LLVMIntEQ cons-ptr
                        (LLVMConstNull CONS-CELL-PTR) "")
         after-block non-nil-block)
       (LLVMPositionBuilderAtEnd $builder non-nil-block)
       (set-gr-value cons-ptr (llvm-i8<-int 3))
       (LLVMBuildBr $builder after-block)
       (LLVMPositionBuilderAtEnd $builder after-block)
       cons-ptr)))
    ((func-type? type-spec)
     (check-type val LLVM-LAMBDA-T)
     (let ((closure-ptr (LLVMBuildIntToPtr $builder (remove-lowtag val) CLOSURE-PTR ""))
           (arity (func-type-arity type-spec)))
       (llvm-build-call
         $builder
         (runtime-func "rt_check_arity" VOID (list CLOSURE-PTR INT))
         (list closure-ptr (llvm-i32<-int arity))
         "")
       (if (or (any? (lambda (t) (not (eq? t '?)))
                     (func-type-arg-types type-spec))
               (not (eq? (func-type-return-type type-spec) '?)))
         ;; All closures stored as dynamic values must take dynamic values as
         ;; arguments and return dynamic values. If we are making a function that
         ;; doesn't, we must generate a proxy that does the coercions at runtime.
         (compile-proxy-function
           context
           (make-term (list 'func (repeat arity '?) '-> '?) closure-ptr false)
           type-spec)
         ;; Otherwise we're all good, as the function type we want already
         ;; takes dynamic values and returns a dynamic value.
         closure-ptr)))
    ((type-eq? type-spec 'type)
     ;; TODO: We should have a separate exttag for types so that we can do a
     ;; check-type here.
     (LLVMBuildLShr $builder val (llvm-i64<-int (+ LOWTAG-BITS EXTTAG-BITS)) ""))
    (true (fail! context
                 (format nil "Unsupported type-spec '~'" type-spec)
                 blame-source-loc
                 CONS-CELL-PTR false))))

(defun dynamic-val<-static-val (context type-spec val blame-source-loc)
  (cond
    ((type-eq? type-spec '*)
      (add-lowtag
        (let ((box (gc-alloc PTR-BYTES)))
          (LLVMBuildStore $builder (LLVMBuildPtrToInt $builder val NUC-VAL "") box)
          box)
        FOREIGN-LOWTAG))
    ((type-eq? type-spec 'void) LLVM-NIL)
    ((integral? type-spec)
     (fixnum<-llvm-int (LLVMBuildIntCast $builder val NUC-VAL "cast-int-to-nuc-val")))
    ((type-eq? type-spec 'float)
     (LLVMBuildOr
       $builder
       (LLVMBuildShl
         $builder
         (LLVMBuildIntCast
           $builder
           (LLVMBuildBitCast $builder val
                             (llvm-type<-type-spec context type-spec) "")
           (LLVMIntType 64)
           "")
         (llvm-i64<-int (+ LOWTAG-BITS EXTTAG-BITS))
         "")
       (llvm-i64<-int (+ EXTTAG-LOWTAG (<< FLOAT-EXTTAG LOWTAG-BITS)))
       ""))
    ((type-eq? type-spec 'bool)
     (let ((zero (LLVMConstInt (LLVMTypeOf val) 0 false)))
       (LLVMBuildSelect $builder
                        (LLVMBuildICmp $builder LLVMIntEQ val zero "")
                        LLVM-FALSE LLVM-TRUE "")))
    ((type-eq? type-spec 'string)
     (add-lowtag val STRING-LOWTAG))
    ((type-eq? type-spec 'symbol)
     (LLVMBuildOr
       $builder
       (LLVMBuildShl $builder (LLVMBuildZExt $builder val NUC-VAL "")
                     (llvm-i64<-int LOWTAG-BITS)
                     "")
       (llvm-i64<-int SYMBOL-LOWTAG)
       ""))
    ((list-type? type-spec)
     (convert-list
       val
       (lambda (cons-ptr)
         (set-car-value
           cons-ptr
           (coerce context
                   (make-term (car-type type-spec) (get-car-value cons-ptr) false)
                   '?
                   ;; TODO: source loc
                   $dummy-source-loc))
         (set-cdr-value
           cons-ptr
           (coerce context
                   (make-term (cdr-type type-spec) (get-cdr-value cons-ptr) false)
                   '?
                   ;; TODO: source loc
                   $dummy-source-loc))
         (set-gr-value cons-ptr 3))
       (lambda (cons-ptr) cons-ptr))
     (add-lowtag val CONS-LOWTAG))
    ((cons-type? type-spec)
     (add-lowtag (guarded-ref<-static-cons context val type-spec '(cons ? ?)
                                           blame-source-loc)
                 CONS-LOWTAG))
    ((type-eq? type-spec 'type)
     (LLVMBuildOr
       $builder
       (LLVMBuildShl $builder val (llvm-i32<-int (+ LOWTAG-BITS EXTTAG-BITS)) "")
       (llvm-i32<-int (+ EXTTAG-LOWTAG (<< DISCRETE-EXTTAG LOWTAG-BITS)))
       ""))
    ((func-type? type-spec)
     (let ((closure-ptr
             (if (and (all? (lambda (t) (eq? t '?)) (func-type-arg-types type-spec))
                      (eq? (func-type-return-type type-spec) '?))
               val
               (compile-proxy-function
                 context (make-term type-spec val false)
                 (list 'func (repeat (func-type-arity type-spec) '?) '-> '?)))))
       (add-lowtag closure-ptr LAMBDA-LOWTAG)))
    (true (fail! context
                 (format nil "Unsupported type-spec '~'" type-spec)
                 blame-source-loc
                 NUC-VAL false))))

(defun implicit-conversion (context term typ blame-source-loc)
  (when $output-debug-info (format true "(implicit-conversion ... ~ ~)" term typ))
  (cond
    ((and (integral? (tt term)) (integral? typ))
     (LLVMBuildIntCast
       $builder
       (tv term)
       (llvm-type<-type-spec context typ)
       ""))
    ((and (integral? (tt term)) (floating-point? typ))
     (LLVMBuildSIToFP
       $builder
       (tv term)
       (llvm-type<-type-spec context typ)
       ""))
    ((and (floating-point? (tt term)) (integral? typ))
     (LLVMBuildFPToSI
       $builder
       (tv term)
       (llvm-type<-type-spec context typ)
       ""))
    ((and (floating-point? (tt term)) (floating-point? typ))
     (LLVMBuildFPExt
       $builder
       (tv term)
       (llvm-type<-type-spec context typ)
       ""))
    ((and (type-eq? (tt term) 'string) (type-eq? typ 'char*))
     (LLVMBuildBitCast
       $builder
       (LLVMBuildStructGEP $builder (tv term) 1 "")
       CHAR*
       ""))
    ;; TODO: this sucks
    ((and (type-eq? (tt term) 'cons) (type-eq? typ 'array))
     (llvm-build-call
       $builder
       (runtime-func "rt_list_to_array" (llvm-type<-type-spec context typ) (list NUC-VAL))
       (list (add-lowtag (guarded-ref<-static-cons context (tv term) (tt term)
                                                   '(cons ? ?)
                                                   blame-source-loc)
                         CONS-LOWTAG))
       "array<-list"))
    ((and (func-type? (tt term)) (func-type? typ))
     (cond
       ((not (and (eq? (func-type-arity (tt term)) (func-type-arity typ))))
        (fail! context
               (format nil "Static type error: function of incorrect arity ~ used where ~ was expected"
                       (func-type-arity (tt term)) (func-type-arity typ))
               blame-source-loc
               (llvm-type<-type-spec context typ) false))
       ((not (and
               (all? (lambda (c) (compatible? (car c) (cdr c)))
                     (zip (func-type-arg-types (tt term)) (func-type-arg-types typ)))
               (compatible? (func-type-return-type (tt term))
                            (func-type-return-type typ))))
        (fail! context
               (format nil "Static type error: function of type '~' used where '~' was expected"
                       (tt term) typ)
               blame-source-loc
               (llvm-type<-type-spec context typ) false))
       (true (compile-proxy-function context term typ))))
    (true (fail! context
                 (format nil
                         "Static type error: tried to use a term of type '~' where '~' was expected"
                         (tt term) typ)
                 blame-source-loc
                 (llvm-type<-type-spec context typ) false))))

;;; Given a list of terms (which are arguments to some arithmetic builtin) this
;;; converts them all to the "maximum" type, where f64 > f32 > i64 > i32 > i16 > i8
(defun arithmetic-conversion (context terms blame-source-loc)
  (let ((max-type 'u8)
        (terms
          (map
            (lambda (term)
              (if (or (type-eq? (tt term) '?) (numeric? (tt term)))
                term
                (fail! context
                       (format nil "Static type error: tried to use a term of type '~' where a numeric type was expected" (tt term))
                       blame-source-loc
                       'i64 false)))
            terms)))
    (each (lambda (term)
            (let ((typ (tt term)))
              (cond
                ;; TODO: change this when we have doubles
                ((floating-point? typ)
                 (set max-type typ))
                ((> (type-size context typ)
                    (type-size context max-type))
                 (set max-type typ)))))
          terms)
    ;; We need to make sure we have an actual integral type at this point, not
    ;; a tagged value.
    ;; TODO: We shouldn't assume it's an integer just because it's dynamic, we
    ;; need to check for float too.
    (if (type-eq? max-type '?)
      (set max-type 'i64))
    (cons max-type
          (map (lambda (term) (tv (coerce context term max-type blame-source-loc)))
               terms))))
