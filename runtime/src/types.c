#include <stdio.h>
#include <stdlib.h>
#include "assert.h"
#include "nuc.h"

nuc_val rt_type(nuc_val val)
{
	switch (LOWTAG(val)) {
	case FIXNUM_LOWTAG: return FIXNUM_TYPE;
	case STRUCT_LOWTAG: return STRUCT_TYPE;
	case CONS_LOWTAG: return CONS_TYPE;
	case SYMBOL_LOWTAG:  return SYMBOL_TYPE;
	case STRING_LOWTAG: return STRING_TYPE;
	case LAMBDA_LOWTAG: return LAMBDA_TYPE;
	case FOREIGN_LOWTAG: return FOREIGN_TYPE;
	case EXTTAG_LOWTAG:
		switch (EXTTAG(val)) {
		case DISCRETE_EXTTAG:
			switch (val) {
			case TRUE: case FALSE: return BOOL_TYPE;
			}

			printf("Got an invalid discrete value %lu\n", val);
			UNREACHABLE;
		case FLOAT_EXTTAG: return FLOAT_TYPE;
		}

		printf("Got an invalid exttag '%d'\n", (int)EXTTAG(val));
		UNREACHABLE;
	}

	printf("Got an invalid lowtag '%d'\n", (int)LOWTAG(val));
	UNREACHABLE;
}

static const char *type_name(nuc_val type)
{

	switch (type) {
#define CASE(x) case x##_TYPE: return #x;
		CASE(FIXNUM) CASE(STRUCT) CASE(CONS) CASE(SYMBOL) CASE(STRING)
		CASE(LAMBDA) CASE(FOREIGN) CASE(BOOL) CASE(FLOAT)
#undef CASE
	default:
		printf("Got type %d (ft = %d)\n", (int)type, (int)FIXNUM_TYPE);
		UNREACHABLE;
	}

}

// TODO: Dump more info: number of fields, and for each field its name, type,
// and offset within the struct. This can then be used for fun stuff like
// incorporating struct literals into the reader and printer.
// NOTE: This corresponds to the structure defined in compiler/types.nuc, in
// generate-type-table.
typedef struct TypeInfo
{
	const char *name;
} TypeInfo;

// This table is generated by the compiler - the definition doesn't exist
// anywhere in runtime/
extern TypeInfo nuc_type_info_table[];
//TypeInfo nuc_type_info_table[] = {};

static const char *value_type_name(nuc_val value)
{
	if (rt_type(value) != STRUCT_TYPE) {
		return type_name(rt_type(value));
	} else {
		return nuc_type_info_table[STRUCT_ID(value)].name;
	}
}

// TODO: doesn't handle exttags
// TODO: use libbacktrace for better error messages
// TODO: Combine this with rt_check_struct_type
void rt_check_type_from_c(nuc_val val, nuc_val expected_type,
		const char *file, const char *func, int line)
{
	nuc_val given_type = rt_type(val);
	if (given_type != expected_type) {
		fprintf(stderr, "Wrong type given! Expected %s, got %s.\n",
				value_type_name(expected_type), type_name(given_type));
		if (file != NULL)
			fprintf(stderr, "Error occured at %s:%d in %s\n", file, line, func);

		// TODO: Rather than exit(1), we should use abort or something so that
		// it gets caught by the debugger.
		exit(1);
	}
}

void rt_check_type(nuc_val val, nuc_val expected_type)
{
	rt_check_type_from_c(val, expected_type, NULL, NULL, 0);
}

void rt_check_struct_type(nuc_val val, int type_id)
{
	if (LOWTAG(val) != STRUCT_LOWTAG || STRUCT_ID(val) != type_id) {
		fprintf(stderr, "Wrong type given! Expected %s, got %s.\n",
				nuc_type_info_table[type_id].name,
				value_type_name(val));
		// TODO: See above about abort.
		exit(1);
	}
}
