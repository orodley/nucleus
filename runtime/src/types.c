#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "assert.h"
#include "nuc.h"

nuc_val rt_type(nuc_val val)
{
	switch (LOWTAG(val)) {
	case FIXNUM_LOWTAG: return FIXNUM_TYPE;
	case STRUCT_LOWTAG: return STRUCT_TYPE;
	case CONS_LOWTAG: return CONS_TYPE;
	case SYMBOL_LOWTAG:  return SYMBOL_TYPE;
	case STRING_LOWTAG: return STRING_TYPE;
	case LAMBDA_LOWTAG: return LAMBDA_TYPE;
	case FOREIGN_LOWTAG: return FOREIGN_TYPE;
	case EXTTAG_LOWTAG:
		switch (EXTTAG(val)) {
		case DISCRETE_EXTTAG:
			switch (val) {
			case TRUE: case FALSE: return BOOL_TYPE;
			}

			printf("Got an invalid discrete value %lu\n", val);
			UNREACHABLE;
		case FLOAT_EXTTAG: return FLOAT_TYPE;
		}

		printf("Got an invalid exttag '%d'\n", (int)EXTTAG(val));
		UNREACHABLE;
	}

	printf("Got an invalid lowtag '%d'\n", (int)LOWTAG(val));
	UNREACHABLE;
}

static const char *type_name(nuc_val type)
{

	switch (type) {
#define CASE(x) case x##_TYPE: return #x;
		CASE(FIXNUM) CASE(STRUCT) CASE(CONS) CASE(SYMBOL) CASE(STRING)
		CASE(LAMBDA) CASE(FOREIGN) CASE(BOOL) CASE(FLOAT)
#undef CASE
	default:
		printf("Got type %ld (ft = %d)\n", type, (int)FIXNUM_TYPE);
		UNREACHABLE;
	}

}

typedef struct FieldInfo
{
	// TODO: This should be a nucleus String object instead.
	const char *name;
} FieldInfo;

// TODO: Dump more info: number of fields, and for each field its name, type,
// and offset within the struct. This can then be used for fun stuff like
// incorporating struct literals into the reader and printer.
// NOTE: This corresponds to the structure defined in compiler/types.nuc, in
// generate-type-table.
typedef struct StructInfo
{
	// TODO: This should be a nucleus String object instead.
	const char *name;
	uint32_t num_fields;
	FieldInfo *fields;
} StructInfo;

// This table is generated by the compiler - the definition doesn't exist
// anywhere in runtime/
// TODO: We should also write out the size of the table so we can do sanity
// checks rather than just reading garbage memory.
extern StructInfo nuc_type_info_table[];

static const char *value_type_name(nuc_val value)
{
	if (rt_type(value) != STRUCT_TYPE) {
		return type_name(rt_type(value));
	} else {
		return nuc_type_info_table[STRUCT_ID(value)].name;
	}
}

// TODO: doesn't handle exttags
// TODO: use libbacktrace for better error messages
// TODO: Combine this with rt_check_struct_type
void rt_check_type_from_c(nuc_val val, nuc_val expected_type,
		const char *file, const char *func, int line)
{
	nuc_val given_type = rt_type(val);
	if (given_type != expected_type) {
		fprintf(stderr, "Wrong type given! Expected %s, got %s.\n",
				type_name(expected_type), value_type_name(val));
		if (file != NULL)
			fprintf(stderr, "Error occured at %s:%d in %s\n", file, line, func);

		// TODO: Rather than exit(1), we should use abort or something so that
		// it gets caught by the debugger.
		exit(1);
	}
}

void rt_check_type(nuc_val val, nuc_val expected_type)
{
	rt_check_type_from_c(val, expected_type, NULL, NULL, 0);
}

void rt_check_struct_type(nuc_val val, int type_id)
{
	if (LOWTAG(val) != STRUCT_LOWTAG || STRUCT_ID(val) != type_id) {
		fprintf(stderr, "Wrong type given! Expected %s, got %s.\n",
				nuc_type_info_table[type_id].name,
				value_type_name(val));
		// TODO: See above about abort.
		exit(1);
	}
}

// TODO: Bounds checking for these two.

String *rt_get_struct_name(nuc_val val)
{
	CHECK(val, STRUCT_TYPE);
	const char *name = nuc_type_info_table[STRUCT_ID(val)].name;

	return rt_make_string(strlen(name), name);
}

uint32_t rt_get_struct_num_fields(nuc_val val)
{
	CHECK(val, STRUCT_TYPE);
	return nuc_type_info_table[STRUCT_ID(val)].num_fields;
}

nuc_val rt_get_struct_field_names(nuc_val val)
{
	CHECK(val, STRUCT_TYPE);

	StructInfo *struct_info = &nuc_type_info_table[STRUCT_ID(val)];
	FieldInfo *fields = struct_info->fields;

	nuc_val current_cons = NIL;
	for (uint32_t i = struct_info->num_fields; i != 0; i--) {
		FieldInfo *field = &fields[i - 1];
		String *field_name = rt_make_string(strlen(field->name), field->name);
		nuc_val field_name_val = (nuc_val)field_name | STRING_LOWTAG;

		Cons *new_cons = malloc(sizeof(*new_cons));
		new_cons->car = field_name_val;
		new_cons->cdr = current_cons;
		new_cons->guarded_reference_flags = 3; // Both fields are dynamic
		current_cons = (nuc_val)new_cons | CONS_LOWTAG;
	}

	return current_cons;
}
