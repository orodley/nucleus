#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "assert.h"
#include "nuc.h"

nuc_val rt_type(nuc_val val)
{
	switch (LOWTAG(val)) {
	case FIXNUM_LOWTAG: return FIXNUM_TYPE;
	case STRUCT_LOWTAG: return STRUCT_TYPE;
	case CONS_LOWTAG: return CONS_TYPE;
	case SYMBOL_LOWTAG:  return SYMBOL_TYPE;
	case STRING_LOWTAG: return STRING_TYPE;
	case LAMBDA_LOWTAG: return LAMBDA_TYPE;
	case FOREIGN_LOWTAG: return FOREIGN_TYPE;
	case EXTTAG_LOWTAG:
		switch (EXTTAG(val)) {
		case DISCRETE_EXTTAG:
			switch (val) {
			case TRUE: case FALSE: return BOOL_TYPE;
			}

			printf("Got an invalid discrete value %lu\n", val);
			UNREACHABLE;
		case FLOAT_EXTTAG: return FLOAT_TYPE;
		}

		printf("Got an invalid exttag '%d'\n", (int)EXTTAG(val));
		UNREACHABLE;
	}

	printf("Got an invalid lowtag '%d'\n", (int)LOWTAG(val));
	UNREACHABLE;
}

static const char *type_name(nuc_val type)
{

	switch (type) {
#define CASE(x) case x##_TYPE: return #x;
		CASE(FIXNUM) CASE(STRUCT) CASE(CONS) CASE(SYMBOL) CASE(STRING)
		CASE(LAMBDA) CASE(FOREIGN) CASE(BOOL) CASE(FLOAT) CASE(DYNAMIC)
#undef CASE
	default:
		printf("Got type %ld (ft = %d)\n", type, (int)FIXNUM_TYPE);
		UNREACHABLE;
	}

}

typedef struct FieldInfo
{
	// TODO: This should be a nucleus String object instead.
	const char *name;
	nuc_val type;
	uint32_t offset;
} FieldInfo;

// NOTE: This corresponds to the structure defined in compiler/types.nuc, in
// generate-type-table.
typedef struct StructInfo
{
	// TODO: This should be a nucleus String object instead.
	const char *name;
	uint32_t num_fields;
	FieldInfo *fields;
} StructInfo;

// This table and the variable indicating its size are generated by the
// compiler - the definition doesn't exist anywhere in the runtime.
extern StructInfo nuc_type_info_table[];
extern int32_t nuc_type_info_table_size;
//int32_t nuc_type_info_table_size = 10000;

static inline bool type_info_table_available()
{
	return nuc_type_info_table_size != -1;
}

static inline const char *struct_name(int type_id)
{
	assert(type_id < nuc_type_info_table_size);

	return type_info_table_available() ?
		nuc_type_info_table[type_id].name :
		"STRUCT";
}

static const char *value_type_name(nuc_val value)
{
	if (rt_type(value) == STRUCT_TYPE) {
		return struct_name(STRUCT_ID(value));
	} else {
		return type_name(rt_type(value));
	}
}

// TODO: doesn't handle exttags
// TODO: use libbacktrace for better error messages
// TODO: Combine this with rt_check_struct_type
void rt_check_type_from_c(nuc_val val, nuc_val expected_type,
		const char *file, const char *func, int line)
{
	nuc_val given_type = rt_type(val);
	if (given_type != expected_type) {
		fprintf(stderr, "Wrong type given! Expected %s, got %s.\n",
				type_name(expected_type), value_type_name(val));
		if (file != NULL)
			fprintf(stderr, "Error occured at %s:%d in %s\n", file, line, func);

		// TODO: Rather than exit(1), we should use abort or something so that
		// it gets caught by the debugger.
		exit(1);
	}
}

void rt_check_type(nuc_val val, nuc_val expected_type)
{
	rt_check_type_from_c(val, expected_type, NULL, NULL, 0);
}

void rt_check_struct_type(nuc_val val, int type_id)
{
	if (LOWTAG(val) != STRUCT_LOWTAG || STRUCT_ID(val) != type_id) {
		fprintf(stderr, "Wrong type given! Expected %s, got %s.\n",
				struct_name(type_id), value_type_name(val));
		// TODO: See above about abort.
		exit(1);
	}
}

int32_t rt_type_info_table_available()
{
	return type_info_table_available();
}

String *rt_get_struct_name(nuc_val val)
{
	CHECK(val, STRUCT_TYPE);
	const char *name = struct_name(STRUCT_ID(val));

	return rt_make_string(strlen(name), name);
}

int32_t rt_get_struct_num_fields(nuc_val val)
{
	CHECK(val, STRUCT_TYPE);
	assert((int)STRUCT_ID(val) < nuc_type_info_table_size);

	return type_info_table_available() ?
		nuc_type_info_table[STRUCT_ID(val)].num_fields :
		-1;
}

nuc_val rt_get_struct_field_names(nuc_val val)
{
	CHECK(val, STRUCT_TYPE);
	assert((int)STRUCT_ID(val) < nuc_type_info_table_size);

	if (!type_info_table_available())
		return NIL;

	StructInfo *struct_info = &nuc_type_info_table[STRUCT_ID(val)];
	FieldInfo *fields = struct_info->fields;

	nuc_val current_cons = NIL;
	for (uint32_t i = struct_info->num_fields; i != 0; i--) {
		FieldInfo *field = &fields[i - 1];
		String *field_name = rt_make_string(strlen(field->name), field->name);
		nuc_val field_name_val = (nuc_val)field_name | STRING_LOWTAG;

		Cons *new_cons = malloc(sizeof(*new_cons));
		new_cons->car = field_name_val;
		new_cons->cdr = current_cons;
		new_cons->guarded_reference_flags = 3; // Both fields are dynamic
		current_cons = (nuc_val)new_cons | CONS_LOWTAG;
	}

	return current_cons;
}

static nuc_val make_dynamic(uint8_t *value_ptr, nuc_val type)
{
	switch (type) {
	case FIXNUM_TYPE: return INT_TO_NUC_VAL(*(uint32_t *)value_ptr);
	case BOOL_TYPE: return *(uint32_t *)value_ptr ? TRUE : FALSE;
	case FLOAT_TYPE: return float_to_nuc_val(*(float *)value_ptr);
	case SYMBOL_TYPE:
		return (((nuc_val)*(uint32_t *)value_ptr) << LOWTAG_BITS) | SYMBOL_LOWTAG;
	case DYNAMIC_TYPE: return *(nuc_val *)value_ptr;

#define PTR_CASE(type_name) \
	case type_name##_TYPE: \
		return ((nuc_val)*(void **)value_ptr) | type_name##_LOWTAG;
	PTR_CASE(CONS)
	PTR_CASE(FOREIGN)
	PTR_CASE(STRING)
	PTR_CASE(LAMBDA)
	// TODO: Currently we can't add the tag, as our current crippled run time
	// type object doesn't track that
	case STRUCT_TYPE: return NIL;
	default:
		UNREACHABLE;
	}
}

nuc_val rt_get_struct_field_values(nuc_val val)
{
	CHECK(val, STRUCT_TYPE);
	assert((int)STRUCT_ID(val) < nuc_type_info_table_size);

	if (!type_info_table_available())
		return NIL;

	StructInfo *struct_info = &nuc_type_info_table[STRUCT_ID(val)];
	FieldInfo *fields = struct_info->fields;
	uint8_t *struct_ptr = STRUCT_PTR(val);

	if (strcmp(struct_info->name, "Func") == 0) {
		volatile int x = 23;
		(void)x;
	}

	nuc_val current_cons = NIL;
	for (uint32_t i = struct_info->num_fields; i != 0; i--) {
		FieldInfo *field = &fields[i - 1];
		uint8_t *field_ptr = struct_ptr + field->offset;
		nuc_val field_value = make_dynamic(field_ptr, field->type);

		Cons *new_cons = malloc(sizeof(*new_cons));
		new_cons->car = field_value;
		new_cons->cdr = current_cons;
		new_cons->guarded_reference_flags = 3; // Both fields are dynamic
		current_cons = (nuc_val)new_cons | CONS_LOWTAG;
	}

	return current_cons;
}
